{"ast":null,"code":"import * as React from \"react\";\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\n\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\n\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\n\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\n\nfunction traverseFiber(fiber, ascending, selector) {\n  if (!fiber) return;\n  if (selector(fiber) === true) return fiber;\n  let child = ascending ? fiber.return : fiber.child;\n\n  while (child) {\n    const match = traverseFiber(child, ascending, selector);\n    if (match) return match;\n    child = child.sibling;\n  }\n}\n\nfunction wrapContext(context) {\n  try {\n    return Object.defineProperties(context, {\n      _currentRenderer: {\n        get() {\n          return null;\n        },\n\n        set() {}\n\n      },\n      _currentRenderer2: {\n        get() {\n          return null;\n        },\n\n        set() {}\n\n      }\n    });\n  } catch (_) {\n    return context;\n  }\n}\n\nconst FiberContext = wrapContext(React.createContext(null));\n\nclass FiberProvider extends React.Component {\n  render() {\n    return /* @__PURE__ */React.createElement(FiberContext.Provider, {\n      value: this._reactInternals\n    }, this.props.children);\n  }\n\n}\n\nconst {\n  ReactCurrentOwner,\n  ReactCurrentDispatcher\n} = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction useFiber() {\n  const root = React.useContext(FiberContext);\n  if (!root) throw new Error(\"its-fine: useFiber must be called within a <FiberProvider />!\");\n  const id = React.useId();\n  const fiber = React.useMemo(() => {\n    var _a;\n\n    return (_a = ReactCurrentOwner.current) != null ? _a : traverseFiber(root, false, node => {\n      let state = node.memoizedState;\n\n      while (state) {\n        if (state.memoizedState === id) return true;\n        state = state.next;\n      }\n    });\n  }, [root, id]);\n  return fiber;\n}\n\nfunction useContainer() {\n  const fiber = useFiber();\n  const root = React.useMemo(() => traverseFiber(fiber, true, node => {\n    var _a;\n\n    return ((_a = node.stateNode) == null ? void 0 : _a.containerInfo) != null;\n  }), [fiber]);\n  return root == null ? void 0 : root.stateNode.containerInfo;\n}\n\nfunction useNearestChild(type) {\n  const fiber = useFiber();\n  const childRef = React.useRef();\n  React.useLayoutEffect(() => {\n    var _a;\n\n    childRef.current = (_a = traverseFiber(fiber, false, node => typeof node.type === \"string\" && (type === void 0 || node.type === type))) == null ? void 0 : _a.stateNode;\n  }, [fiber]);\n  return childRef;\n}\n\nfunction useNearestParent(type) {\n  const fiber = useFiber();\n  const parentRef = React.useRef();\n  React.useLayoutEffect(() => {\n    var _a;\n\n    parentRef.current = (_a = traverseFiber(fiber, true, node => typeof node.type === \"string\" && (type === void 0 || node.type === type))) == null ? void 0 : _a.stateNode;\n  }, [fiber]);\n  return parentRef;\n}\n\nconst contexts = [];\nconst values = /* @__PURE__ */new WeakMap();\n\nfunction useContextBridge() {\n  var _a;\n\n  const fiber = useFiber();\n  contexts.splice(0, contexts.length);\n  traverseFiber(fiber, true, node => {\n    var _a2;\n\n    const context = (_a2 = node.type) == null ? void 0 : _a2._context;\n    if (context && context !== FiberContext) contexts.push(wrapContext(context));\n  });\n\n  for (const context of contexts) {\n    const value = (_a = ReactCurrentDispatcher.current) == null ? void 0 : _a.readContext(context);\n    values.set(context, value);\n  }\n\n  return React.useMemo(() => contexts.reduce((Prev, context) => props => /* @__PURE__ */React.createElement(Prev, null, /* @__PURE__ */React.createElement(context.Provider, __spreadProps(__spreadValues({}, props), {\n    value: values.get(context)\n  }))), props => /* @__PURE__ */React.createElement(FiberProvider, __spreadValues({}, props))), []);\n}\n\nexport { FiberProvider, traverseFiber, useContainer, useContextBridge, useFiber, useNearestChild, useNearestParent };","map":{"version":3,"mappings":"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","names":["fiber","ascending","selector","child","return","match","traverseFiber","sibling","wrapContext","context","defineProperties","_currentRenderer","get","set","_currentRenderer2","_","FiberContext","React","createContext","Component","render","Provider","value","_reactInternals","props","children","ReactCurrentOwner","ReactCurrentDispatcher","__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED","useFiber","useContext","root","Error","useId","useMemo","current","_a","node","state","memoizedState","id","next","useContainer","containerInfo","stateNode","useNearestChild","type","useRef","useLayoutEffect","childRef","useNearestParent","parentRef","contexts","values","WeakMap","useContextBridge","length","_context","readContext","reduce","Prev"],"sources":["C:\\Users\\Asus\\Documents\\threejs\\miro learning\\20.12 neuroweb textures\\node_modules\\its-fine\\src\\index.tsx"],"sourcesContent":["import * as React from 'react'\nimport type ReactReconciler from 'react-reconciler'\n\n/**\n * Represents a react-internal Fiber node.\n */\nexport type Fiber<T = any> = Omit<ReactReconciler.Fiber, 'stateNode'> & { stateNode: T }\n\n/**\n * Represents a {@link Fiber} node selector for traversal.\n */\nexport type FiberSelector<T = any> = (\n  /** The current {@link Fiber} node. */\n  node: Fiber<T | null>,\n) => boolean | void\n\n/**\n * Traverses up or down a {@link Fiber}, return `true` to stop and select a node.\n */\nexport function traverseFiber<T = any>(\n  /** Input {@link Fiber} to traverse. */\n  fiber: Fiber | undefined,\n  /** Whether to ascend and walk up the tree. Will walk down if `false`. */\n  ascending: boolean,\n  /** A {@link Fiber} node selector, returns the first match when `true` is passed. */\n  selector: FiberSelector<T>,\n): Fiber<T> | undefined {\n  if (!fiber) return\n  if (selector(fiber) === true) return fiber\n\n  let child = ascending ? fiber.return : fiber.child\n  while (child) {\n    const match = traverseFiber(child, ascending, selector)\n    if (match) return match\n\n    child = child.sibling\n  }\n}\n\n// In development, React will warn about using contexts between renderers.\n// Hide the warning because its-fine fixes this issue\n// https://github.com/facebook/react/pull/12779\nfunction wrapContext<T>(context: React.Context<T>): React.Context<T> {\n  try {\n    return Object.defineProperties(context, {\n      _currentRenderer: {\n        get() {\n          return null\n        },\n        set() {},\n      },\n      _currentRenderer2: {\n        get() {\n          return null\n        },\n        set() {},\n      },\n    })\n  } catch (_) {\n    return context\n  }\n}\n\nconst FiberContext = wrapContext(React.createContext<Fiber>(null!))\n\n/**\n * A react-internal {@link Fiber} provider. This component binds React children to the React Fiber tree. Call its-fine hooks within this.\n */\nexport class FiberProvider extends React.Component<{ children?: React.ReactNode }> {\n  private _reactInternals!: Fiber\n\n  render() {\n    return <FiberContext.Provider value={this._reactInternals}>{this.props.children}</FiberContext.Provider>\n  }\n}\n\ninterface ReactInternal {\n  __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {\n    ReactCurrentOwner: React.RefObject<Fiber>\n    ReactCurrentDispatcher: React.RefObject<{ readContext<T>(context: React.Context<T>): T }>\n  }\n}\n\nconst { ReactCurrentOwner, ReactCurrentDispatcher } = (React as unknown as ReactInternal)\n  .__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED\n\n/**\n * Returns the current react-internal {@link Fiber}. This is an implementation detail of [react-reconciler](https://github.com/facebook/react/tree/main/packages/react-reconciler).\n */\nexport function useFiber(): Fiber<null> | undefined {\n  const root = React.useContext(FiberContext)\n  if (!root) throw new Error('its-fine: useFiber must be called within a <FiberProvider />!')\n\n  // In development mode, React will expose the current component's Fiber as ReactCurrentOwner.\n  // In production, we don't have this luxury and must traverse from FiberProvider via useId\n  const id = React.useId()\n  const fiber = React.useMemo(\n    () =>\n      ReactCurrentOwner.current ??\n      traverseFiber<null>(root, false, (node) => {\n        let state = node.memoizedState\n        while (state) {\n          if (state.memoizedState === id) return true\n          state = state.next\n        }\n      }),\n    [root, id],\n  )\n\n  return fiber\n}\n\n/**\n * Represents a react-reconciler container instance.\n */\nexport interface ContainerInstance<T = any> {\n  containerInfo: T\n}\n\n/**\n * Returns the current react-reconciler container info passed to {@link ReactReconciler.Reconciler.createContainer}.\n *\n * In react-dom, a container will point to the root DOM element; in react-three-fiber, it will point to the root Zustand store.\n */\nexport function useContainer<T = any>(): T | undefined {\n  const fiber = useFiber()\n  const root = React.useMemo(\n    () => traverseFiber<ContainerInstance<T>>(fiber, true, (node) => node.stateNode?.containerInfo != null),\n    [fiber],\n  )\n\n  return root?.stateNode.containerInfo\n}\n\n/**\n * Returns the nearest react-reconciler child instance or the node created from {@link ReactReconciler.HostConfig.createInstance}.\n *\n * In react-dom, this would be a DOM element; in react-three-fiber this would be an instance descriptor.\n */\nexport function useNearestChild<T = any>(\n  /** An optional element type to filter to. */\n  type?: keyof JSX.IntrinsicElements,\n): React.MutableRefObject<T | undefined> {\n  const fiber = useFiber()\n  const childRef = React.useRef<T>()\n\n  React.useLayoutEffect(() => {\n    childRef.current = traverseFiber<T>(\n      fiber,\n      false,\n      (node) => typeof node.type === 'string' && (type === undefined || node.type === type),\n    )?.stateNode\n  }, [fiber])\n\n  return childRef\n}\n\n/**\n * Returns the nearest react-reconciler parent instance or the node created from {@link ReactReconciler.HostConfig.createInstance}.\n *\n * In react-dom, this would be a DOM element; in react-three-fiber this would be an instance descriptor.\n */\nexport function useNearestParent<T = any>(\n  /** An optional element type to filter to. */\n  type?: keyof JSX.IntrinsicElements,\n): React.MutableRefObject<T | undefined> {\n  const fiber = useFiber()\n  const parentRef = React.useRef<T>()\n\n  React.useLayoutEffect(() => {\n    parentRef.current = traverseFiber<T>(\n      fiber,\n      true,\n      (node) => typeof node.type === 'string' && (type === undefined || node.type === type),\n    )?.stateNode\n  }, [fiber])\n\n  return parentRef\n}\n\n/**\n * Represents a react-context bridge provider component.\n */\nexport type ContextBridge = React.FC<React.PropsWithChildren<{}>>\n\n// Live context and their memoized values\nconst contexts: React.Context<any>[] = []\nconst values = new WeakMap<React.Context<any>, any>()\n\n/**\n * React Context currently cannot be shared across [React renderers](https://reactjs.org/docs/codebase-overview.html#renderers) but explicitly forwarded between providers (see [react#17275](https://github.com/facebook/react/issues/17275)). This hook returns a {@link ContextBridge} of live context providers to pierce Context across renderers.\n *\n * Pass {@link ContextBridge} as a component to a secondary renderer to enable context-sharing within its children.\n */\nexport function useContextBridge(): ContextBridge {\n  const fiber = useFiber()\n\n  // Collect live context\n  contexts.splice(0, contexts.length)\n  traverseFiber(fiber, true, (node) => {\n    const context = node.type?._context\n    if (context && context !== FiberContext) contexts.push(wrapContext(context))\n  })\n\n  // Update memoized values\n  for (const context of contexts) {\n    const value = ReactCurrentDispatcher.current?.readContext(context)\n    values.set(context, value)\n  }\n\n  // Flatten context and their memoized values into a `ContextBridge` provider\n  return React.useMemo(\n    () =>\n      contexts.reduce(\n        (Prev, context) => (props) =>\n          (\n            <Prev>\n              <context.Provider {...props} value={values.get(context)} />\n            </Prev>\n          ),\n        (props) => <FiberProvider {...props} />,\n      ),\n    [],\n  )\n}\n"]},"metadata":{},"sourceType":"module"}