{"ast":null,"code":"/**\n * @license\n * Copyright 2016 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n/**\n * @module\n * @private\n */\n'use strict';\n\nvar binary = require('@mapbox/node-pre-gyp/lib/pre-binding');\n\nvar path = require('path');\n\nvar binding_path = binary.find(path.resolve(path.join(__dirname, '../package.json')));\nvar binding;\n\ntry {\n  binding = require(binding_path);\n} catch (e) {\n  let fs = require('fs');\n\n  let searchPath = path.dirname(path.dirname(binding_path));\n  let searchName = path.basename(path.dirname(binding_path));\n  let foundNames;\n\n  try {\n    foundNames = fs.readdirSync(searchPath);\n  } catch (readDirError) {\n    let message = `The gRPC binary module was not installed. This may be fixed by running \"npm rebuild\"\nOriginal error: ${e.message}`;\n    let error = new Error(message);\n    error.code = e.code;\n    throw error;\n  }\n\n  if (foundNames.indexOf(searchName) === -1) {\n    let message = `Failed to load gRPC binary module because it was not installed for the current system\nExpected directory: ${searchName}\nFound: [${foundNames.join(', ')}]\nThis problem can often be fixed by running \"npm rebuild\" on the current system\nOriginal error: ${e.message}`;\n    let error = new Error(message);\n    error.code = e.code;\n    throw error;\n  } else {\n    e.message = `Failed to load ${binding_path}. ${e.message}`;\n    throw e;\n  }\n}\n\nmodule.exports = binding;","map":{"version":3,"names":["binary","require","path","binding_path","find","resolve","join","__dirname","binding","e","fs","searchPath","dirname","searchName","basename","foundNames","readdirSync","readDirError","message","error","Error","code","indexOf","module","exports"],"sources":["C:/Users/Asus/Documents/threejs/miro learning/20.12 neuroweb textures/node_modules/grpc/src/grpc_extension.js"],"sourcesContent":["/**\n * @license\n * Copyright 2016 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n/**\n * @module\n * @private\n */\n\n'use strict';\n\nvar binary = require('@mapbox/node-pre-gyp/lib/pre-binding');\nvar path = require('path');\nvar binding_path =\n    binary.find(path.resolve(path.join(__dirname, '../package.json')));\nvar binding;\ntry {\n  binding = require(binding_path);\n} catch (e) {\n  let fs = require('fs');\n  let searchPath = path.dirname(path.dirname(binding_path));\n  let searchName = path.basename(path.dirname(binding_path));\n  let foundNames;\n  try {\n    foundNames = fs.readdirSync(searchPath);\n  } catch (readDirError) {\n    let message = `The gRPC binary module was not installed. This may be fixed by running \"npm rebuild\"\nOriginal error: ${e.message}`;\n    let error = new Error(message);\n    error.code = e.code;\n    throw error;\n  }\n  if (foundNames.indexOf(searchName) === -1) {\n    let message = `Failed to load gRPC binary module because it was not installed for the current system\nExpected directory: ${searchName}\nFound: [${foundNames.join(', ')}]\nThis problem can often be fixed by running \"npm rebuild\" on the current system\nOriginal error: ${e.message}`;\n    let error = new Error(message);\n    error.code = e.code;\n    throw error;\n  } else {\n    e.message = `Failed to load ${binding_path}. ${e.message}`;\n    throw e;\n  }\n}\n\nmodule.exports = binding;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,sCAAD,CAApB;;AACA,IAAIC,IAAI,GAAGD,OAAO,CAAC,MAAD,CAAlB;;AACA,IAAIE,YAAY,GACZH,MAAM,CAACI,IAAP,CAAYF,IAAI,CAACG,OAAL,CAAaH,IAAI,CAACI,IAAL,CAAUC,SAAV,EAAqB,iBAArB,CAAb,CAAZ,CADJ;AAEA,IAAIC,OAAJ;;AACA,IAAI;EACFA,OAAO,GAAGP,OAAO,CAACE,YAAD,CAAjB;AACD,CAFD,CAEE,OAAOM,CAAP,EAAU;EACV,IAAIC,EAAE,GAAGT,OAAO,CAAC,IAAD,CAAhB;;EACA,IAAIU,UAAU,GAAGT,IAAI,CAACU,OAAL,CAAaV,IAAI,CAACU,OAAL,CAAaT,YAAb,CAAb,CAAjB;EACA,IAAIU,UAAU,GAAGX,IAAI,CAACY,QAAL,CAAcZ,IAAI,CAACU,OAAL,CAAaT,YAAb,CAAd,CAAjB;EACA,IAAIY,UAAJ;;EACA,IAAI;IACFA,UAAU,GAAGL,EAAE,CAACM,WAAH,CAAeL,UAAf,CAAb;EACD,CAFD,CAEE,OAAOM,YAAP,EAAqB;IACrB,IAAIC,OAAO,GAAI;AACnB,kBAAkBT,CAAC,CAACS,OAAQ,EADxB;IAEA,IAAIC,KAAK,GAAG,IAAIC,KAAJ,CAAUF,OAAV,CAAZ;IACAC,KAAK,CAACE,IAAN,GAAaZ,CAAC,CAACY,IAAf;IACA,MAAMF,KAAN;EACD;;EACD,IAAIJ,UAAU,CAACO,OAAX,CAAmBT,UAAnB,MAAmC,CAAC,CAAxC,EAA2C;IACzC,IAAIK,OAAO,GAAI;AACnB,sBAAsBL,UAAW;AACjC,UAAUE,UAAU,CAACT,IAAX,CAAgB,IAAhB,CAAsB;AAChC;AACA,kBAAkBG,CAAC,CAACS,OAAQ,EAJxB;IAKA,IAAIC,KAAK,GAAG,IAAIC,KAAJ,CAAUF,OAAV,CAAZ;IACAC,KAAK,CAACE,IAAN,GAAaZ,CAAC,CAACY,IAAf;IACA,MAAMF,KAAN;EACD,CATD,MASO;IACLV,CAAC,CAACS,OAAF,GAAa,kBAAiBf,YAAa,KAAIM,CAAC,CAACS,OAAQ,EAAzD;IACA,MAAMT,CAAN;EACD;AACF;;AAEDc,MAAM,CAACC,OAAP,GAAiBhB,OAAjB"},"metadata":{},"sourceType":"script"}