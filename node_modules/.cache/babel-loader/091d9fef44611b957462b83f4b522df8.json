{"ast":null,"code":"/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n/**\n * Client Interceptors\n *\n * This module describes the interceptor framework for clients.\n * An interceptor is a function which takes an options object and a nextCall\n * function and returns an InterceptingCall:\n *\n * ```\n * var interceptor = function(options, nextCall) {\n *   return new InterceptingCall(nextCall(options));\n * }\n * ```\n *\n * The interceptor function must return an InterceptingCall object. Returning\n * `new InterceptingCall(nextCall(options))` will satisfy the contract (but\n * provide no interceptor functionality). `nextCall` is a function which will\n * generate the next interceptor in the chain.\n *\n * To implement interceptor functionality, create a requester and pass it to\n * the InterceptingCall constructor:\n *\n * `return new InterceptingCall(nextCall(options), requester);`\n *\n * A requester is a POJO with zero or more of the following methods:\n *\n * `start(metadata, listener, next)`\n * * To continue, call next(metadata, listener). Listeners are described\n * * below.\n *\n * `sendMessage(message, next)`\n * * To continue, call next(message).\n *\n * `halfClose(next)`\n * * To continue, call next().\n *\n * `cancel(message, next)`\n * * To continue, call next().\n *\n * A listener is a POJO with one or more of the following methods:\n *\n * `onReceiveMetadata(metadata, next)`\n * * To continue, call next(metadata)\n *\n * `onReceiveMessage(message, next)`\n * * To continue, call next(message)\n *\n * `onReceiveStatus(status, next)`\n * * To continue, call next(status)\n *\n * A listener is provided by the requester's `start` method. The provided\n * listener implements all the inbound interceptor methods, which can be called\n * to short-circuit the gRPC call.\n *\n * Three usage patterns are supported for listeners:\n * 1) Pass the listener along without modification: `next(metadata, listener)`.\n *   In this case the interceptor declines to intercept any inbound operations.\n * 2) Create a new listener with one or more inbound interceptor methods and\n *   pass it to `next`. In this case the interceptor will fire on the inbound\n *   operations implemented in the new listener.\n * 3) Make direct inbound calls to the provided listener's methods. This\n *   short-circuits the interceptor stack.\n *\n * Do not modify the listener passed in. Either pass it along unmodified,\n * ignore it, or call methods on it to short-circuit the call.\n *\n * To intercept errors, implement the `onReceiveStatus` method and test for\n * `status.code !== grpc.status.OK`.\n *\n * To intercept trailers, examine `status.metadata` in the `onReceiveStatus`\n * method.\n *\n * This is a trivial implementation of all interceptor methods:\n * var interceptor = function(options, nextCall) {\n *   return new InterceptingCall(nextCall(options), {\n *     start: function(metadata, listener, next) {\n *       next(metadata, {\n *         onReceiveMetadata: function (metadata, next) {\n *           next(metadata);\n *         },\n *         onReceiveMessage: function (message, next) {\n *           next(message);\n *         },\n *         onReceiveStatus: function (status, next) {\n *           next(status);\n *         },\n *       });\n *     },\n *     sendMessage: function(message, next) {\n *       next(message);\n *     },\n *     halfClose: function(next) {\n *       next();\n *     },\n *     cancel: function(message, next) {\n *       next();\n *     }\n *   });\n * };\n *\n * This is an interceptor with a single method:\n * var interceptor = function(options, nextCall) {\n *   return new InterceptingCall(nextCall(options), {\n *     sendMessage: function(message, next) {\n *       next(message);\n *     }\n *   });\n * };\n *\n * Builders are provided for convenience: StatusBuilder, ListenerBuilder,\n * and RequesterBuilder\n *\n * gRPC client operations use this mapping to interceptor methods:\n *\n * grpc.opType.SEND_INITIAL_METADATA -> start\n * grpc.opType.SEND_MESSAGE -> sendMessage\n * grpc.opType.SEND_CLOSE_FROM_CLIENT -> halfClose\n * grpc.opType.RECV_INITIAL_METADATA -> onReceiveMetadata\n * grpc.opType.RECV_MESSAGE -> onReceiveMessage\n * grpc.opType.RECV_STATUS_ON_CLIENT -> onReceiveStatus\n *\n * @module\n */\n'use strict';\n\nvar grpc = require('./grpc_extension');\n\nvar Metadata = require('./metadata');\n\nvar constants = require('./constants');\n\nvar common = require('./common');\n\nvar methodTypes = constants.methodTypes;\n\nvar EventEmitter = require('events').EventEmitter;\n/**\n * A custom error thrown when interceptor configuration fails.\n * @param {string} message The error message\n * @param {object=} extra\n * @constructor\n */\n\n\nvar InterceptorConfigurationError = function InterceptorConfigurationError(message, extra) {\n  Error.captureStackTrace(this, this.constructor);\n  this.name = this.constructor.name;\n  this.message = message;\n  this.extra = extra;\n};\n\nrequire('util').inherits(InterceptorConfigurationError, Error);\n/**\n * A builder for gRPC status objects.\n * @constructor\n */\n\n\nfunction StatusBuilder() {\n  this.code = null;\n  this.details = null;\n  this.metadata = null;\n}\n/**\n * Adds a status code to the builder.\n * @param {number} code The status code.\n * @return {StatusBuilder}\n */\n\n\nStatusBuilder.prototype.withCode = function (code) {\n  this.code = code;\n  return this;\n};\n/**\n * Adds details to the builder.\n * @param {string} details A status message.\n * @return {StatusBuilder}\n */\n\n\nStatusBuilder.prototype.withDetails = function (details) {\n  this.details = details;\n  return this;\n};\n/**\n * Adds metadata to the builder.\n * @param {Metadata} metadata The gRPC status metadata.\n * @return {StatusBuilder}\n */\n\n\nStatusBuilder.prototype.withMetadata = function (metadata) {\n  this.metadata = metadata;\n  return this;\n};\n/**\n * Builds the status object.\n * @return {grpc~StatusObject} A gRPC status.\n */\n\n\nStatusBuilder.prototype.build = function () {\n  var status = {};\n\n  if (this.code !== undefined) {\n    status.code = this.code;\n  }\n\n  if (this.details) {\n    status.details = this.details;\n  }\n\n  if (this.metadata) {\n    status.metadata = this.metadata;\n  }\n\n  return status;\n};\n/**\n * A builder for listener interceptors.\n * @constructor\n */\n\n\nfunction ListenerBuilder() {\n  this.metadata = null;\n  this.message = null;\n  this.status = null;\n}\n/**\n * Adds an onReceiveMetadata method to the builder.\n * @param {MetadataListener} on_receive_metadata A listener method for\n * receiving metadata.\n * @return {ListenerBuilder}\n */\n\n\nListenerBuilder.prototype.withOnReceiveMetadata = function (on_receive_metadata) {\n  this.metadata = on_receive_metadata;\n  return this;\n};\n/**\n * Adds an onReceiveMessage method to the builder.\n * @param {MessageListener} on_receive_message A listener method for receiving\n * messages.\n * @return {ListenerBuilder}\n */\n\n\nListenerBuilder.prototype.withOnReceiveMessage = function (on_receive_message) {\n  this.message = on_receive_message;\n  return this;\n};\n/**\n * Adds an onReceiveStatus method to the builder.\n * @param {StatusListener} on_receive_status A listener method for receiving\n * status.\n * @return {ListenerBuilder}\n */\n\n\nListenerBuilder.prototype.withOnReceiveStatus = function (on_receive_status) {\n  this.status = on_receive_status;\n  return this;\n};\n/**\n * Builds the call listener.\n * @return {grpc~Listener}\n */\n\n\nListenerBuilder.prototype.build = function () {\n  var self = this;\n  var listener = {};\n  listener.onReceiveMetadata = self.metadata;\n  listener.onReceiveMessage = self.message;\n  listener.onReceiveStatus = self.status;\n  return listener;\n};\n/**\n * A builder for the outbound methods of an interceptor.\n * @constructor\n */\n\n\nfunction RequesterBuilder() {\n  this.start = null;\n  this.message = null;\n  this.half_close = null;\n  this.cancel = null;\n}\n/**\n * Add a metadata requester to the builder.\n * @param {MetadataRequester} start A requester method for handling metadata.\n * @return {RequesterBuilder}\n */\n\n\nRequesterBuilder.prototype.withStart = function (start) {\n  this.start = start;\n  return this;\n};\n/**\n * Add a message requester to the builder.\n * @param {MessageRequester} send_message A requester method for handling\n * messages.\n * @return {RequesterBuilder}\n */\n\n\nRequesterBuilder.prototype.withSendMessage = function (send_message) {\n  this.message = send_message;\n  return this;\n};\n/**\n * Add a close requester to the builder.\n * @param {CloseRequester} half_close A requester method for handling client\n * close.\n * @return {RequesterBuilder}\n */\n\n\nRequesterBuilder.prototype.withHalfClose = function (half_close) {\n  this.half_close = half_close;\n  return this;\n};\n/**\n * Add a cancel requester to the builder.\n * @param {CancelRequester} cancel A requester method for handling `cancel`\n * @return {RequesterBuilder}\n */\n\n\nRequesterBuilder.prototype.withCancel = function (cancel) {\n  this.cancel = cancel;\n  return this;\n};\n/**\n * Builds the requester's interceptor methods.\n * @return {grpc~Requester}\n */\n\n\nRequesterBuilder.prototype.build = function () {\n  var requester = {};\n  requester.start = this.start;\n  requester.sendMessage = this.message;\n  requester.halfClose = this.half_close;\n  requester.cancel = this.cancel;\n  return requester;\n};\n/**\n * Transforms a list of interceptor providers into interceptors.\n * @param {InterceptorProvider[]} providers\n * @param {grpc~MethodDefinition} method_definition\n * @return {null|Interceptor[]}\n */\n\n\nvar resolveInterceptorProviders = function (providers, method_definition) {\n  if (!Array.isArray(providers)) {\n    return null;\n  }\n\n  var interceptors = [];\n\n  for (var i = 0; i < providers.length; i++) {\n    var provider = providers[i];\n    var interceptor = provider(method_definition);\n\n    if (interceptor) {\n      interceptors.push(interceptor);\n    }\n  }\n\n  return interceptors;\n};\n/**\n * A chainable gRPC call proxy which will delegate to an optional requester\n * object. By default, interceptor methods will chain to next_call. If a\n * requester is provided which implements an interceptor method, that\n * requester method will be executed as part of the chain.\n * @param {InterceptingCall|null} next_call The next call in the chain\n * @param {grpc~Requester=} requester Interceptor methods to handle request\n * operations.\n * @constructor\n */\n\n\nfunction InterceptingCall(next_call, requester) {\n  this.next_call = next_call;\n  this.requester = requester;\n}\n\nconst emptyNext = function () {};\n/**\n * Get the next method in the chain or a no-op function if we are at the end\n * of the chain\n * @param {string} method_name\n * @return {function} The next method in the chain\n * @private\n */\n\n\nInterceptingCall.prototype._getNextCall = function (method_name) {\n  return this.next_call ? this.next_call[method_name].bind(this.next_call) : emptyNext;\n};\n/**\n * Call the next method in the chain. This will either be on the next\n * InterceptingCall (next_call), or the requester if the requester\n * implements the method.\n * @param {string} method_name The name of the interceptor method\n * @param {array=} args Payload arguments for the operation\n * @param {function=} next The next InterceptingCall's method\n * @return {null}\n * @private\n */\n\n\nInterceptingCall.prototype._callNext = function (method_name, args, next) {\n  var args_array = args || [];\n  var next_call = next ? next : this._getNextCall(method_name);\n\n  if (this.requester && this.requester[method_name]) {\n    // Avoid using expensive `apply` calls\n    var num_args = args_array.length;\n\n    switch (num_args) {\n      case 0:\n        return this.requester[method_name](next_call);\n\n      case 1:\n        return this.requester[method_name](args_array[0], next_call);\n\n      case 2:\n        return this.requester[method_name](args_array[0], args_array[1], next_call);\n    }\n  } else {\n    if (next_call === emptyNext) {\n      throw new Error('Interceptor call chain terminated unexpectedly');\n    }\n\n    return next_call(args_array[0], args_array[1]);\n  }\n};\n/**\n * Starts a call through the outbound interceptor chain and adds an element to\n * the reciprocal inbound listener chain.\n * @param {grpc.Metadata} metadata The outgoing metadata.\n * @param {grpc~Listener} listener An intercepting listener for inbound\n * operations.\n */\n\n\nInterceptingCall.prototype.start = function (metadata, listener) {\n  var self = this; // If the listener provided is an InterceptingListener, use it. Otherwise, we\n  // must be at the end of the listener chain, and any listener operations\n  // should be terminated in an EndListener.\n\n  var next_listener = _getInterceptingListener(listener, new EndListener()); // Build the next method in the interceptor chain\n\n\n  var next = function (metadata, current_listener) {\n    // If there is a next call in the chain, run it. Otherwise do nothing.\n    if (self.next_call) {\n      // Wire together any listener provided with the next listener\n      var listener = _getInterceptingListener(current_listener, next_listener);\n\n      self.next_call.start(metadata, listener);\n    }\n  };\n\n  this._callNext('start', [metadata, next_listener], next);\n};\n/**\n * Pass a message through the interceptor chain.\n * @param {jspb.Message} message\n */\n\n\nInterceptingCall.prototype.sendMessage = function (message) {\n  this._callNext('sendMessage', [message]);\n};\n/**\n * Run a close operation through the interceptor chain\n */\n\n\nInterceptingCall.prototype.halfClose = function () {\n  this._callNext('halfClose');\n};\n/**\n * Run a cancel operation through the interceptor chain\n */\n\n\nInterceptingCall.prototype.cancel = function () {\n  this._callNext('cancel');\n};\n/**\n * Run a cancelWithStatus operation through the interceptor chain.\n * @param {number} code\n * @param {string} details\n */\n\n\nInterceptingCall.prototype.cancelWithStatus = function (code, details) {\n  this._callNext('cancelWithStatus', [code, details]);\n};\n/**\n * Pass a getPeer call down to the base gRPC call (should not be intercepted)\n * @return {object}\n */\n\n\nInterceptingCall.prototype.getPeer = function () {\n  return this._callNext('getPeer');\n};\n/**\n * For streaming calls, we need to transparently pass the stream's context\n * through the interceptor chain. Passes the context between InterceptingCalls\n * but hides it from any requester implementations.\n * @param {object} context Carries objects needed for streaming operations.\n * @param {jspb.Message} message The message to send.\n */\n\n\nInterceptingCall.prototype.sendMessageWithContext = function (context, message) {\n  var next = this.next_call ? this.next_call.sendMessageWithContext.bind(this.next_call, context) : context;\n\n  this._callNext('sendMessage', [message], next);\n};\n/**\n * For receiving streaming messages, we need to seed the base interceptor with\n * the streaming context to create a RECV_MESSAGE batch.\n * @param {object} context Carries objects needed for streaming operations\n */\n\n\nInterceptingCall.prototype.recvMessageWithContext = function (context) {\n  this._callNext('recvMessageWithContext', [context]);\n};\n/**\n * A chain-able listener object which will delegate to a custom listener when\n * appropriate.\n * @param {InterceptingListener|null} next_listener The next\n * InterceptingListener in the chain\n * @param {grpc~Listener=} delegate A custom listener object which may implement\n * specific operations\n * @constructor\n */\n\n\nfunction InterceptingListener(next_listener, delegate) {\n  this.delegate = delegate || {};\n  this.next_listener = next_listener;\n}\n/**\n * Get the next method in the chain or a no-op function if we are at the end\n * of the chain.\n * @param {string} method_name The name of the listener method.\n * @return {function} The next method in the chain\n * @private\n */\n\n\nInterceptingListener.prototype._getNextListener = function (method_name) {\n  return this.next_listener ? this.next_listener[method_name].bind(this.next_listener) : function () {};\n};\n/**\n * Call the next method in the chain. This will either be on the next\n * InterceptingListener (next_listener), or the requester if the requester\n * implements the method.\n * @param {string} method_name The name of the interceptor method\n * @param {array=} args Payload arguments for the operation\n * @param {function=} next The next InterceptingListener's method\n * @return {null}\n * @private\n */\n\n\nInterceptingListener.prototype._callNext = function (method_name, args, next) {\n  var args_array = args || [];\n  var next_listener = next ? next : this._getNextListener(method_name);\n\n  if (this.delegate && this.delegate[method_name]) {\n    // Avoid using expensive `apply` calls\n    var num_args = args_array.length;\n\n    switch (num_args) {\n      case 0:\n        return this.delegate[method_name](next_listener);\n\n      case 1:\n        return this.delegate[method_name](args_array[0], next_listener);\n\n      case 2:\n        return this.delegate[method_name](args_array[0], args_array[1], next_listener);\n    }\n  } else {\n    return next_listener(args_array[0], args_array[1]);\n  }\n};\n/**\n * Inbound metadata receiver.\n * @param {Metadata} metadata\n */\n\n\nInterceptingListener.prototype.onReceiveMetadata = function (metadata) {\n  this._callNext('onReceiveMetadata', [metadata]);\n};\n/**\n * Inbound message receiver.\n * @param {jspb.Message} message\n */\n\n\nInterceptingListener.prototype.onReceiveMessage = function (message) {\n  this._callNext('onReceiveMessage', [message]);\n};\n/**\n * When intercepting streaming message, we need to pass the streaming context\n * transparently along the chain. Hides the context from the delegate listener\n * methods.\n * @param {object} context Carries objects needed for streaming operations.\n * @param {jspb.Message} message The message received.\n */\n\n\nInterceptingListener.prototype.recvMessageWithContext = function (context, message) {\n  var fallback = this.next_listener.recvMessageWithContext;\n  var next_method = this.next_listener ? fallback.bind(this.next_listener, context) : context;\n\n  if (this.delegate.onReceiveMessage) {\n    this.delegate.onReceiveMessage(message, next_method, context);\n  } else {\n    next_method(message);\n  }\n};\n/**\n * Inbound status receiver.\n * @param {grpc~StatusObject} status\n */\n\n\nInterceptingListener.prototype.onReceiveStatus = function (status) {\n  this._callNext('onReceiveStatus', [status]);\n};\n/**\n * A dead-end listener used to terminate a call chain. Used when an interceptor\n * creates a branch chain, when the branch returns the listener chain will\n * terminate here.\n * @constructor\n */\n\n\nfunction EndListener() {}\n\nEndListener.prototype.onReceiveMetadata = function () {};\n\nEndListener.prototype.onReceiveMessage = function () {};\n\nEndListener.prototype.onReceiveStatus = function () {};\n\nEndListener.prototype.recvMessageWithContext = function () {};\n/**\n * Get a call object built with the provided options.\n * @param {grpc.Channel} channel\n * @param {string} path\n * @param {grpc.Client~CallOptions=} options Options object.\n */\n\n\nfunction getCall(channel, path, options) {\n  var deadline;\n  var host;\n  var parent;\n  var propagate_flags;\n  var credentials;\n\n  if (options) {\n    deadline = options.deadline;\n    host = options.host;\n    parent = options.parent ? options.parent.call : undefined;\n    propagate_flags = options.propagate_flags;\n    credentials = options.credentials;\n  }\n\n  if (deadline === undefined) {\n    deadline = Infinity;\n  }\n\n  var call = channel.createCall(path, deadline, host, parent, propagate_flags);\n\n  if (credentials) {\n    call.setCredentials(credentials);\n  }\n\n  return call;\n}\n\nvar OP_DEPENDENCIES = {\n  [grpc.opType.SEND_MESSAGE]: [grpc.opType.SEND_INITIAL_METADATA],\n  [grpc.opType.SEND_CLOSE_FROM_CLIENT]: [grpc.opType.SEND_MESSAGE],\n  [grpc.opType.RECV_MESSAGE]: [grpc.opType.SEND_INITIAL_METADATA]\n};\n/**\n * Produces a callback triggered by streaming response messages.\n * @private\n * @param {EventEmitter} emitter\n * @param {grpc.internal~Call} call\n * @param {function} get_listener Returns a grpc~Listener.\n * @param {grpc~deserialize} deserialize\n * @return {Function}\n */\n\nfunction _getStreamReadCallback(emitter, call, get_listener, deserialize) {\n  return function (err, response) {\n    if (err) {\n      // Something has gone wrong. Stop reading and wait for status\n      emitter.finished = true;\n\n      emitter._readsDone();\n\n      return;\n    }\n\n    var data = response.read;\n    var deserialized;\n\n    try {\n      deserialized = deserialize(data);\n    } catch (e) {\n      common.log(constants.logVerbosity.ERROR, `Response deserialization failed: ${e.message}`);\n\n      emitter._readsDone({\n        code: constants.status.INTERNAL,\n        details: 'Failed to parse server response'\n      });\n\n      return;\n    }\n\n    if (data === null) {\n      emitter._readsDone();\n\n      return;\n    }\n\n    var listener = get_listener();\n    var context = {\n      call: call,\n      listener: listener\n    };\n    listener.recvMessageWithContext(context, deserialized);\n  };\n}\n/**\n * Tests whether a batch can be started.\n * @private\n * @param {number[]} batch_ops The operations in the batch we are checking.\n * @param {number[]} completed_ops Previously completed operations.\n * @return {boolean}\n */\n\n\nfunction _areBatchRequirementsMet(batch_ops, completed_ops) {\n  var dependencies = common.flatMap(batch_ops, function (op) {\n    return OP_DEPENDENCIES[op] || [];\n  });\n\n  for (var i = 0; i < dependencies.length; i++) {\n    var required_dep = dependencies[i];\n\n    if (batch_ops.indexOf(required_dep) === -1 && completed_ops.indexOf(required_dep) === -1) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Enforces the order of operations for synchronous requests. If a batch's\n * operations cannot be started because required operations have not started\n * yet, the batch is deferred until requirements are met.\n * @private\n * @param {grpc.Client~Call} call\n * @param {object} batch\n * @param {object} batch_state\n * @param {number[]} [batch_state.completed_ops] The ops already sent.\n * @param {object} [batch_state.deferred_batches] Batches to be sent after\n *     their dependencies are fulfilled.\n * @param {function} callback\n * @return {object}\n */\n\n\nfunction _startBatchIfReady(call, batch, batch_state, callback) {\n  var completed_ops = batch_state.completed_ops;\n  var deferred_batches = batch_state.deferred_batches;\n  var batch_ops = Object.keys(batch).map(Number);\n\n  if (_areBatchRequirementsMet(batch_ops, completed_ops)) {\n    // Dependencies are met, start the batch and any deferred batches whose\n    // dependencies are met as a result.\n    call.startBatch(batch, callback);\n    completed_ops = Array.from(new Set(completed_ops.concat(batch_ops)));\n    deferred_batches = common.flatMap(deferred_batches, function (deferred_batch) {\n      var deferred_batch_ops = Object.keys(deferred_batch).map(Number);\n\n      if (_areBatchRequirementsMet(deferred_batch_ops, completed_ops)) {\n        call.startBatch(deferred_batch.batch, deferred_batch.callback);\n        return [];\n      }\n\n      return [deferred_batch];\n    });\n  } else {\n    // Dependencies are not met, defer the batch\n    deferred_batches = deferred_batches.concat({\n      batch: batch,\n      callback: callback\n    });\n  }\n\n  return {\n    completed_ops: completed_ops,\n    deferred_batches: deferred_batches\n  };\n}\n/**\n * Produces an interceptor which will start gRPC batches for unary calls.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Channel} channel\n * @param {EventEmitter} emitter\n * @param {function} callback\n * @return {Interceptor}\n */\n\n\nfunction _getUnaryInterceptor(method_definition, channel, emitter, callback) {\n  var serialize = method_definition.requestSerialize;\n  var deserialize = method_definition.responseDeserialize;\n  return function (options) {\n    var call = getCall(channel, method_definition.path, options);\n    var first_listener;\n    var final_requester = {};\n    var batch_state = {\n      completed_ops: [],\n      deferred_batches: []\n    };\n\n    final_requester.start = function (metadata, listener) {\n      var batch = {\n        [grpc.opType.SEND_INITIAL_METADATA]: metadata._getCoreRepresentation()\n      };\n      first_listener = listener;\n      batch_state = _startBatchIfReady(call, batch, batch_state, function () {});\n    };\n\n    final_requester.sendMessage = function (message) {\n      var batch = {\n        [grpc.opType.SEND_MESSAGE]: serialize(message)\n      };\n      batch_state = _startBatchIfReady(call, batch, batch_state, function () {});\n    };\n\n    final_requester.halfClose = function () {\n      var batch = {\n        [grpc.opType.SEND_CLOSE_FROM_CLIENT]: true,\n        [grpc.opType.RECV_INITIAL_METADATA]: true,\n        [grpc.opType.RECV_MESSAGE]: true,\n        [grpc.opType.RECV_STATUS_ON_CLIENT]: true\n      };\n\n      var callback = function (err, response) {\n        response.status.metadata = Metadata._fromCoreRepresentation(response.status.metadata);\n        var status = response.status;\n        var deserialized;\n\n        if (status.code === constants.status.OK) {\n          if (err) {\n            // Got a batch error, but OK status. Something went wrong\n            callback(err);\n            return;\n          } else {\n            try {\n              deserialized = deserialize(response.read);\n            } catch (e) {\n              common.log(constants.logVerbosity.ERROR, `Response deserialization failed: ${e.message}`);\n              /* Change status to indicate bad server response. This\n               * will result in passing an error to the callback */\n\n              status = {\n                code: constants.status.INTERNAL,\n                details: 'Failed to parse server response'\n              };\n            }\n          }\n        }\n\n        response.metadata = Metadata._fromCoreRepresentation(response.metadata);\n        first_listener.onReceiveMetadata(response.metadata);\n        first_listener.onReceiveMessage(deserialized);\n        first_listener.onReceiveStatus(status);\n      };\n\n      batch_state = _startBatchIfReady(call, batch, batch_state, callback);\n    };\n\n    final_requester.cancel = function () {\n      call.cancel();\n    };\n\n    final_requester.cancelWithStatus = function (code, details) {\n      call.cancelWithStatus(code, details);\n    };\n\n    final_requester.getPeer = function () {\n      return call.getPeer();\n    };\n\n    return new InterceptingCall(null, final_requester);\n  };\n}\n/**\n * Produces an interceptor which will start gRPC batches for client streaming\n * calls.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Channel} channel\n * @param {EventEmitter} emitter\n * @param {function} callback\n * @return {Interceptor}\n */\n\n\nfunction _getClientStreamingInterceptor(method_definition, channel, emitter, callback) {\n  var serialize = common.wrapIgnoreNull(method_definition.requestSerialize);\n  var deserialize = method_definition.responseDeserialize;\n  return function (options) {\n    var first_listener;\n    var call = getCall(channel, method_definition.path, options);\n    var final_requester = {};\n\n    final_requester.start = function (metadata, listener) {\n      var metadata_batch = {\n        [grpc.opType.SEND_INITIAL_METADATA]: metadata._getCoreRepresentation(),\n        [grpc.opType.RECV_INITIAL_METADATA]: true\n      };\n      first_listener = listener;\n      call.startBatch(metadata_batch, function (err, response) {\n        if (err) {\n          // The call has stopped for some reason. A non-OK status will arrive\n          // in the other batch.\n          return;\n        }\n\n        response.metadata = Metadata._fromCoreRepresentation(response.metadata);\n        listener.onReceiveMetadata(response.metadata);\n      });\n      var recv_batch = {};\n      recv_batch[grpc.opType.RECV_MESSAGE] = true;\n      recv_batch[grpc.opType.RECV_STATUS_ON_CLIENT] = true;\n      call.startBatch(recv_batch, function (err, response) {\n        response.status.metadata = Metadata._fromCoreRepresentation(response.status.metadata);\n        var status = response.status;\n        var deserialized;\n\n        if (status.code === constants.status.OK) {\n          if (err) {\n            // Got a batch error, but OK status. Something went wrong\n            callback(err);\n            return;\n          } else {\n            try {\n              deserialized = deserialize(response.read);\n            } catch (e) {\n              common.log(constants.logVerbosity.ERROR, `Response deserialization failed: ${e.message}`);\n              /* Change status to indicate bad server response. This will result\n               * in passing an error to the callback */\n\n              status = {\n                code: constants.status.INTERNAL,\n                details: 'Failed to parse server response'\n              };\n            }\n          }\n        }\n\n        listener.onReceiveMessage(deserialized);\n        listener.onReceiveStatus(status);\n      });\n    };\n\n    final_requester.sendMessage = function (chunk, context) {\n      var message;\n      var callback = context && context.callback ? context.callback : function () {};\n      var encoding = context && context.encoding ? context.encoding : '';\n\n      try {\n        message = serialize(chunk);\n      } catch (e) {\n        common.log(constants.logVerbosity.ERROR, `Request serialization failed: ${e.message}`);\n        /* Sending this error to the server and emitting it immediately on the\n           client may put the call in a slightly weird state on the client side,\n           but passing an object that causes a serialization failure is a misuse\n           of the API anyway, so that's OK. The primary purpose here is to give\n           the programmer a useful error and to stop the stream properly */\n\n        call.cancelWithStatus(constants.status.INTERNAL, 'Serialization failure');\n        callback(e);\n        return;\n      }\n\n      if (Number.isFinite(encoding)) {\n        /* Attach the encoding if it is a finite number. This is the closest we\n         * can get to checking that it is valid flags */\n        message.grpcWriteFlags = encoding;\n      }\n\n      var batch = {\n        [grpc.opType.SEND_MESSAGE]: message\n      };\n      call.startBatch(batch, function (err, event) {\n        callback(err, event);\n      });\n    };\n\n    final_requester.halfClose = function () {\n      var batch = {\n        [grpc.opType.SEND_CLOSE_FROM_CLIENT]: true\n      };\n      call.startBatch(batch, function () {});\n    };\n\n    final_requester.cancel = function () {\n      call.cancel();\n    };\n\n    final_requester.cancelWithStatus = function (code, details) {\n      call.cancelWithStatus(code, details);\n    };\n\n    final_requester.getPeer = function () {\n      return call.getPeer();\n    };\n\n    return new InterceptingCall(null, final_requester);\n  };\n}\n/**\n * Produces an interceptor which will start gRPC batches for server streaming\n * calls.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Channel} channel\n * @param {EventEmitter} emitter\n * @return {Interceptor}\n */\n\n\nfunction _getServerStreamingInterceptor(method_definition, channel, emitter) {\n  var deserialize = common.wrapIgnoreNull(method_definition.responseDeserialize);\n  var serialize = method_definition.requestSerialize;\n  return function (options) {\n    var batch_state = {\n      completed_ops: [],\n      deferred_batches: []\n    };\n    var call = getCall(channel, method_definition.path, options);\n    var final_requester = {};\n    var first_listener;\n\n    var get_listener = function () {\n      return first_listener;\n    };\n\n    final_requester.start = function (metadata, listener) {\n      first_listener = listener;\n      metadata = metadata.clone();\n      var metadata_batch = {\n        [grpc.opType.SEND_INITIAL_METADATA]: metadata._getCoreRepresentation(),\n        [grpc.opType.RECV_INITIAL_METADATA]: true\n      };\n\n      var callback = function (err, response) {\n        if (err) {\n          // The call has stopped for some reason. A non-OK status will arrive\n          // in the other batch.\n          return;\n        }\n\n        first_listener.onReceiveMetadata(Metadata._fromCoreRepresentation(response.metadata));\n      };\n\n      batch_state = _startBatchIfReady(call, metadata_batch, batch_state, callback);\n      var status_batch = {\n        [grpc.opType.RECV_STATUS_ON_CLIENT]: true\n      };\n      call.startBatch(status_batch, function (err, response) {\n        if (err) {\n          emitter.emit('error', err);\n          return;\n        }\n\n        response.status.metadata = Metadata._fromCoreRepresentation(response.status.metadata);\n        first_listener.onReceiveStatus(response.status);\n      });\n    };\n\n    final_requester.sendMessage = function (argument) {\n      var message = serialize(argument);\n\n      if (options) {\n        message.grpcWriteFlags = options.flags;\n      }\n\n      var send_batch = {\n        [grpc.opType.SEND_MESSAGE]: message\n      };\n\n      var callback = function (err, response) {\n        if (err) {\n          // The call has stopped for some reason. A non-OK status will arrive\n          // in the other batch.\n          return;\n        }\n      };\n\n      batch_state = _startBatchIfReady(call, send_batch, batch_state, callback);\n    };\n\n    final_requester.halfClose = function () {\n      var batch = {\n        [grpc.opType.SEND_CLOSE_FROM_CLIENT]: true\n      };\n      batch_state = _startBatchIfReady(call, batch, batch_state, function () {});\n    };\n\n    final_requester.recvMessageWithContext = function (context) {\n      var recv_batch = {\n        [grpc.opType.RECV_MESSAGE]: true\n      };\n\n      var callback = _getStreamReadCallback(emitter, call, get_listener, deserialize);\n\n      batch_state = _startBatchIfReady(call, recv_batch, batch_state, callback);\n    };\n\n    final_requester.cancel = function () {\n      call.cancel();\n    };\n\n    final_requester.cancelWithStatus = function (code, details) {\n      call.cancelWithStatus(code, details);\n    };\n\n    final_requester.getPeer = function () {\n      return call.getPeer();\n    };\n\n    return new InterceptingCall(null, final_requester);\n  };\n}\n/**\n * Produces an interceptor which will start gRPC batches for bi-directional\n * calls.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Channel} channel\n * @param {EventEmitter} emitter\n * @return {Interceptor}\n */\n\n\nfunction _getBidiStreamingInterceptor(method_definition, channel, emitter) {\n  var serialize = common.wrapIgnoreNull(method_definition.requestSerialize);\n  var deserialize = common.wrapIgnoreNull(method_definition.responseDeserialize);\n  return function (options) {\n    var first_listener;\n\n    var get_listener = function () {\n      return first_listener;\n    };\n\n    var call = getCall(channel, method_definition.path, options);\n    var final_requester = {};\n\n    final_requester.start = function (metadata, listener) {\n      var metadata_batch = {\n        [grpc.opType.SEND_INITIAL_METADATA]: metadata._getCoreRepresentation(),\n        [grpc.opType.RECV_INITIAL_METADATA]: true\n      };\n      first_listener = listener;\n      call.startBatch(metadata_batch, function (err, response) {\n        if (err) {\n          // The call has stopped for some reason. A non-OK status will arrive\n          // in the other batch.\n          return;\n        }\n\n        response.metadata = Metadata._fromCoreRepresentation(response.metadata);\n        listener.onReceiveMetadata(response.metadata);\n      });\n      var recv_batch = {};\n      recv_batch[grpc.opType.RECV_STATUS_ON_CLIENT] = true;\n      call.startBatch(recv_batch, function (err, response) {\n        var status = response.status;\n\n        if (status.code === constants.status.OK) {\n          if (err) {\n            emitter.emit('error', err);\n            return;\n          }\n        }\n\n        response.status.metadata = Metadata._fromCoreRepresentation(response.status.metadata);\n        listener.onReceiveStatus(status);\n      });\n    };\n\n    final_requester.sendMessage = function (chunk, context) {\n      var message;\n      var callback = context && context.callback ? context.callback : function () {};\n      var encoding = context && context.encoding ? context.encoding : '';\n\n      try {\n        message = serialize(chunk);\n      } catch (e) {\n        common.log(constants.logVerbosity.ERROR, `Request serialization failed: ${e.message}`);\n        /* Sending this error to the server and emitting it immediately on the\n           client may put the call in a slightly weird state on the client side,\n           but passing an object that causes a serialization failure is a misuse\n           of the API anyway, so that's OK. The primary purpose here is to give\n           the programmer a useful error and to stop the stream properly */\n\n        call.cancelWithStatus(constants.status.INTERNAL, 'Serialization failure');\n        callback(e);\n        return;\n      }\n\n      if (Number.isFinite(encoding)) {\n        /* Attach the encoding if it is a finite number. This is the closest we\n         * can get to checking that it is valid flags */\n        message.grpcWriteFlags = encoding;\n      }\n\n      var batch = {\n        [grpc.opType.SEND_MESSAGE]: message\n      };\n      call.startBatch(batch, function (err, event) {\n        callback(err, event);\n      });\n    };\n\n    final_requester.halfClose = function () {\n      var batch = {\n        [grpc.opType.SEND_CLOSE_FROM_CLIENT]: true\n      };\n      call.startBatch(batch, function () {});\n    };\n\n    final_requester.recvMessageWithContext = function (context) {\n      var recv_batch = {\n        [grpc.opType.RECV_MESSAGE]: true\n      };\n      call.startBatch(recv_batch, _getStreamReadCallback(emitter, call, get_listener, deserialize));\n    };\n\n    final_requester.cancel = function () {\n      call.cancel();\n    };\n\n    final_requester.cancelWithStatus = function (code, details) {\n      call.cancelWithStatus(code, details);\n    };\n\n    final_requester.getPeer = function () {\n      return call.getPeer();\n    };\n\n    return new InterceptingCall(null, final_requester);\n  };\n}\n/**\n * Produces a listener for responding to callers of unary RPCs.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {EventEmitter} emitter\n * @param {function} callback\n * @return {grpc~Listener}\n */\n\n\nfunction _getUnaryListener(method_definition, emitter, callback) {\n  var resultMessage;\n  return {\n    onReceiveMetadata: function (metadata) {\n      emitter.emit('metadata', metadata);\n    },\n    onReceiveMessage: function (message) {\n      resultMessage = message;\n    },\n    onReceiveStatus: function (status) {\n      if (status.code !== constants.status.OK) {\n        var error = common.createStatusError(status);\n        callback(error);\n      } else {\n        callback(null, resultMessage);\n      }\n\n      emitter.emit('status', status);\n    }\n  };\n}\n/**\n * Produces a listener for responding to callers of client streaming RPCs.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {EventEmitter} emitter\n * @param {function} callback\n * @return {grpc~Listener}\n */\n\n\nfunction _getClientStreamingListener(method_definition, emitter, callback) {\n  var resultMessage;\n  return {\n    onReceiveMetadata: function (metadata) {\n      emitter.emit('metadata', metadata);\n    },\n    onReceiveMessage: function (message) {\n      resultMessage = message;\n    },\n    onReceiveStatus: function (status) {\n      if (status.code !== constants.status.OK) {\n        var error = common.createStatusError(status);\n        callback(error);\n      } else {\n        callback(null, resultMessage);\n      }\n\n      emitter.emit('status', status);\n    }\n  };\n}\n/**\n * Produces a listener for responding to callers of server streaming RPCs.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {EventEmitter} emitter\n * @return {grpc~Listener}\n */\n\n\nfunction _getServerStreamingListener(method_definition, emitter) {\n  var deserialize = common.wrapIgnoreNull(method_definition.responseDeserialize);\n  return {\n    onReceiveMetadata: function (metadata) {\n      emitter.emit('metadata', metadata);\n    },\n    onReceiveMessage: function (message, next, context) {\n      if (emitter.push(message) && message !== null) {\n        var call = context.call;\n\n        var get_listener = function () {\n          return context.listener;\n        };\n\n        var read_batch = {};\n        read_batch[grpc.opType.RECV_MESSAGE] = true;\n        call.startBatch(read_batch, _getStreamReadCallback(emitter, call, get_listener, deserialize));\n      } else {\n        emitter.reading = false;\n      }\n    },\n    onReceiveStatus: function (status) {\n      emitter._receiveStatus(status);\n    }\n  };\n}\n/**\n * Produces a listener for responding to callers of bi-directional RPCs.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {EventEmitter} emitter\n * @return {grpc~Listener}\n */\n\n\nfunction _getBidiStreamingListener(method_definition, emitter) {\n  var deserialize = common.wrapIgnoreNull(method_definition.responseDeserialize);\n  return {\n    onReceiveMetadata: function (metadata) {\n      emitter.emit('metadata', metadata);\n    },\n    onReceiveMessage: function (message, next, context) {\n      if (emitter.push(message) && message !== null) {\n        var call = context.call;\n\n        var get_listener = function () {\n          return context.listener;\n        };\n\n        var read_batch = {};\n        read_batch[grpc.opType.RECV_MESSAGE] = true;\n        call.startBatch(read_batch, _getStreamReadCallback(emitter, call, get_listener, deserialize));\n      } else {\n        emitter.reading = false;\n      }\n    },\n    onReceiveStatus: function (status) {\n      emitter._receiveStatus(status);\n    }\n  };\n}\n\nvar interceptorGenerators = {\n  [methodTypes.UNARY]: _getUnaryInterceptor,\n  [methodTypes.CLIENT_STREAMING]: _getClientStreamingInterceptor,\n  [methodTypes.SERVER_STREAMING]: _getServerStreamingInterceptor,\n  [methodTypes.BIDI_STREAMING]: _getBidiStreamingInterceptor\n};\nvar listenerGenerators = {\n  [methodTypes.UNARY]: _getUnaryListener,\n  [methodTypes.CLIENT_STREAMING]: _getClientStreamingListener,\n  [methodTypes.SERVER_STREAMING]: _getServerStreamingListener,\n  [methodTypes.BIDI_STREAMING]: _getBidiStreamingListener\n};\n/**\n * Creates the last listener in an interceptor stack.\n * @param {grpc~MethodDefinition} method_definition\n * @param {EventEmitter} emitter\n * @param {function=} callback\n * @return {grpc~Listener}\n */\n\nfunction getLastListener(method_definition, emitter, callback) {\n  if (typeof emitter === 'function') {\n    callback = emitter;\n\n    callback = function () {};\n  }\n\n  if (typeof callback !== 'function') {\n    callback = function () {};\n  }\n\n  if (!(emitter instanceof EventEmitter && typeof callback === 'function')) {\n    throw new Error('Argument mismatch in getLastListener');\n  }\n\n  var method_type = common.getMethodType(method_definition);\n  var generator = listenerGenerators[method_type];\n  return generator(method_definition, emitter, callback);\n}\n/**\n *\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Client~CallOptions} options\n * @param {Interceptor[]} interceptors\n * @param {grpc.Channel} channel\n * @param {function|EventEmitter} responder\n */\n\n\nfunction getInterceptingCall(method_definition, options, interceptors, channel, responder) {\n  var last_interceptor = _getLastInterceptor(method_definition, channel, responder);\n\n  var all_interceptors = interceptors.concat(last_interceptor);\n  return _buildChain(all_interceptors, options);\n}\n/**\n * Creates the last interceptor in an interceptor stack.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Channel} channel\n * @param {function|EventEmitter} responder\n * @return {Interceptor}\n */\n\n\nfunction _getLastInterceptor(method_definition, channel, responder) {\n  var callback = typeof responder === 'function' ? responder : function () {};\n  var emitter = responder instanceof EventEmitter ? responder : new EventEmitter();\n  var method_type = common.getMethodType(method_definition);\n  var generator = interceptorGenerators[method_type];\n  return generator(method_definition, channel, emitter, callback);\n}\n/**\n * Chain a list of interceptors together and return the first InterceptingCall.\n * @private\n * @param {Interceptor[]} interceptors An interceptor stack.\n * @param {grpc.Client~CallOptions} options Call options.\n * @return {InterceptingCall}\n */\n\n\nfunction _buildChain(interceptors, options) {\n  var next = function (interceptors) {\n    if (interceptors.length === 0) {\n      return function (options) {};\n    }\n\n    var head_interceptor = interceptors[0];\n    var rest_interceptors = interceptors.slice(1);\n    return function (options) {\n      return head_interceptor(options, next(rest_interceptors));\n    };\n  };\n\n  var chain = next(interceptors)(options);\n  return new InterceptingCall(chain);\n}\n/**\n * Wraps a plain listener object in an InterceptingListener if it isn't an\n * InterceptingListener already.\n * @param {InterceptingListener|object|null} current_listener\n * @param {InterceptingListener|EndListener} next_listener\n * @return {InterceptingListener|null}\n * @private\n */\n\n\nfunction _getInterceptingListener(current_listener, next_listener) {\n  if (!_isInterceptingListener(current_listener)) {\n    return new InterceptingListener(next_listener, current_listener);\n  }\n\n  return current_listener;\n}\n/**\n * Test if the listener exists and is an InterceptingListener.\n * @param listener\n * @return {boolean}\n * @private\n */\n\n\nfunction _isInterceptingListener(listener) {\n  return listener && listener.constructor.name === 'InterceptingListener';\n}\n\nexports.resolveInterceptorProviders = resolveInterceptorProviders;\nexports.InterceptingCall = InterceptingCall;\nexports.ListenerBuilder = ListenerBuilder;\nexports.RequesterBuilder = RequesterBuilder;\nexports.StatusBuilder = StatusBuilder;\nexports.InterceptorConfigurationError = InterceptorConfigurationError;\nexports.getInterceptingCall = getInterceptingCall;\nexports.getLastListener = getLastListener;","map":{"version":3,"names":["grpc","require","Metadata","constants","common","methodTypes","EventEmitter","InterceptorConfigurationError","message","extra","Error","captureStackTrace","constructor","name","inherits","StatusBuilder","code","details","metadata","prototype","withCode","withDetails","withMetadata","build","status","undefined","ListenerBuilder","withOnReceiveMetadata","on_receive_metadata","withOnReceiveMessage","on_receive_message","withOnReceiveStatus","on_receive_status","self","listener","onReceiveMetadata","onReceiveMessage","onReceiveStatus","RequesterBuilder","start","half_close","cancel","withStart","withSendMessage","send_message","withHalfClose","withCancel","requester","sendMessage","halfClose","resolveInterceptorProviders","providers","method_definition","Array","isArray","interceptors","i","length","provider","interceptor","push","InterceptingCall","next_call","emptyNext","_getNextCall","method_name","bind","_callNext","args","next","args_array","num_args","next_listener","_getInterceptingListener","EndListener","current_listener","cancelWithStatus","getPeer","sendMessageWithContext","context","recvMessageWithContext","InterceptingListener","delegate","_getNextListener","fallback","next_method","getCall","channel","path","options","deadline","host","parent","propagate_flags","credentials","call","Infinity","createCall","setCredentials","OP_DEPENDENCIES","opType","SEND_MESSAGE","SEND_INITIAL_METADATA","SEND_CLOSE_FROM_CLIENT","RECV_MESSAGE","_getStreamReadCallback","emitter","get_listener","deserialize","err","response","finished","_readsDone","data","read","deserialized","e","log","logVerbosity","ERROR","INTERNAL","_areBatchRequirementsMet","batch_ops","completed_ops","dependencies","flatMap","op","required_dep","indexOf","_startBatchIfReady","batch","batch_state","callback","deferred_batches","Object","keys","map","Number","startBatch","from","Set","concat","deferred_batch","deferred_batch_ops","_getUnaryInterceptor","serialize","requestSerialize","responseDeserialize","first_listener","final_requester","_getCoreRepresentation","RECV_INITIAL_METADATA","RECV_STATUS_ON_CLIENT","_fromCoreRepresentation","OK","_getClientStreamingInterceptor","wrapIgnoreNull","metadata_batch","recv_batch","chunk","encoding","isFinite","grpcWriteFlags","event","_getServerStreamingInterceptor","clone","status_batch","emit","argument","flags","send_batch","_getBidiStreamingInterceptor","_getUnaryListener","resultMessage","error","createStatusError","_getClientStreamingListener","_getServerStreamingListener","read_batch","reading","_receiveStatus","_getBidiStreamingListener","interceptorGenerators","UNARY","CLIENT_STREAMING","SERVER_STREAMING","BIDI_STREAMING","listenerGenerators","getLastListener","method_type","getMethodType","generator","getInterceptingCall","responder","last_interceptor","_getLastInterceptor","all_interceptors","_buildChain","head_interceptor","rest_interceptors","slice","chain","_isInterceptingListener","exports"],"sources":["C:/Users/Asus/Documents/threejs/miro learning/20.12 neuroweb textures/node_modules/grpc/src/client_interceptors.js"],"sourcesContent":["/**\n * @license\n * Copyright 2018 gRPC authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n */\n\n/**\n * Client Interceptors\n *\n * This module describes the interceptor framework for clients.\n * An interceptor is a function which takes an options object and a nextCall\n * function and returns an InterceptingCall:\n *\n * ```\n * var interceptor = function(options, nextCall) {\n *   return new InterceptingCall(nextCall(options));\n * }\n * ```\n *\n * The interceptor function must return an InterceptingCall object. Returning\n * `new InterceptingCall(nextCall(options))` will satisfy the contract (but\n * provide no interceptor functionality). `nextCall` is a function which will\n * generate the next interceptor in the chain.\n *\n * To implement interceptor functionality, create a requester and pass it to\n * the InterceptingCall constructor:\n *\n * `return new InterceptingCall(nextCall(options), requester);`\n *\n * A requester is a POJO with zero or more of the following methods:\n *\n * `start(metadata, listener, next)`\n * * To continue, call next(metadata, listener). Listeners are described\n * * below.\n *\n * `sendMessage(message, next)`\n * * To continue, call next(message).\n *\n * `halfClose(next)`\n * * To continue, call next().\n *\n * `cancel(message, next)`\n * * To continue, call next().\n *\n * A listener is a POJO with one or more of the following methods:\n *\n * `onReceiveMetadata(metadata, next)`\n * * To continue, call next(metadata)\n *\n * `onReceiveMessage(message, next)`\n * * To continue, call next(message)\n *\n * `onReceiveStatus(status, next)`\n * * To continue, call next(status)\n *\n * A listener is provided by the requester's `start` method. The provided\n * listener implements all the inbound interceptor methods, which can be called\n * to short-circuit the gRPC call.\n *\n * Three usage patterns are supported for listeners:\n * 1) Pass the listener along without modification: `next(metadata, listener)`.\n *   In this case the interceptor declines to intercept any inbound operations.\n * 2) Create a new listener with one or more inbound interceptor methods and\n *   pass it to `next`. In this case the interceptor will fire on the inbound\n *   operations implemented in the new listener.\n * 3) Make direct inbound calls to the provided listener's methods. This\n *   short-circuits the interceptor stack.\n *\n * Do not modify the listener passed in. Either pass it along unmodified,\n * ignore it, or call methods on it to short-circuit the call.\n *\n * To intercept errors, implement the `onReceiveStatus` method and test for\n * `status.code !== grpc.status.OK`.\n *\n * To intercept trailers, examine `status.metadata` in the `onReceiveStatus`\n * method.\n *\n * This is a trivial implementation of all interceptor methods:\n * var interceptor = function(options, nextCall) {\n *   return new InterceptingCall(nextCall(options), {\n *     start: function(metadata, listener, next) {\n *       next(metadata, {\n *         onReceiveMetadata: function (metadata, next) {\n *           next(metadata);\n *         },\n *         onReceiveMessage: function (message, next) {\n *           next(message);\n *         },\n *         onReceiveStatus: function (status, next) {\n *           next(status);\n *         },\n *       });\n *     },\n *     sendMessage: function(message, next) {\n *       next(message);\n *     },\n *     halfClose: function(next) {\n *       next();\n *     },\n *     cancel: function(message, next) {\n *       next();\n *     }\n *   });\n * };\n *\n * This is an interceptor with a single method:\n * var interceptor = function(options, nextCall) {\n *   return new InterceptingCall(nextCall(options), {\n *     sendMessage: function(message, next) {\n *       next(message);\n *     }\n *   });\n * };\n *\n * Builders are provided for convenience: StatusBuilder, ListenerBuilder,\n * and RequesterBuilder\n *\n * gRPC client operations use this mapping to interceptor methods:\n *\n * grpc.opType.SEND_INITIAL_METADATA -> start\n * grpc.opType.SEND_MESSAGE -> sendMessage\n * grpc.opType.SEND_CLOSE_FROM_CLIENT -> halfClose\n * grpc.opType.RECV_INITIAL_METADATA -> onReceiveMetadata\n * grpc.opType.RECV_MESSAGE -> onReceiveMessage\n * grpc.opType.RECV_STATUS_ON_CLIENT -> onReceiveStatus\n *\n * @module\n */\n\n'use strict';\n\nvar grpc = require('./grpc_extension');\nvar Metadata = require('./metadata');\nvar constants = require('./constants');\nvar common = require('./common');\nvar methodTypes = constants.methodTypes;\nvar EventEmitter = require('events').EventEmitter;\n\n/**\n * A custom error thrown when interceptor configuration fails.\n * @param {string} message The error message\n * @param {object=} extra\n * @constructor\n */\nvar InterceptorConfigurationError =\n  function InterceptorConfigurationError(message, extra) {\n    Error.captureStackTrace(this, this.constructor);\n    this.name = this.constructor.name;\n    this.message = message;\n    this.extra = extra;\n  };\n\nrequire('util').inherits(InterceptorConfigurationError, Error);\n\n/**\n * A builder for gRPC status objects.\n * @constructor\n */\nfunction StatusBuilder() {\n  this.code = null;\n  this.details = null;\n  this.metadata = null;\n}\n\n/**\n * Adds a status code to the builder.\n * @param {number} code The status code.\n * @return {StatusBuilder}\n */\nStatusBuilder.prototype.withCode = function(code) {\n  this.code = code;\n  return this;\n};\n\n/**\n * Adds details to the builder.\n * @param {string} details A status message.\n * @return {StatusBuilder}\n */\nStatusBuilder.prototype.withDetails = function(details) {\n  this.details = details;\n  return this;\n};\n\n/**\n * Adds metadata to the builder.\n * @param {Metadata} metadata The gRPC status metadata.\n * @return {StatusBuilder}\n */\nStatusBuilder.prototype.withMetadata = function(metadata) {\n  this.metadata = metadata;\n  return this;\n};\n\n/**\n * Builds the status object.\n * @return {grpc~StatusObject} A gRPC status.\n */\nStatusBuilder.prototype.build = function() {\n  var status = {};\n  if (this.code !== undefined) {\n    status.code = this.code;\n  }\n  if (this.details) {\n    status.details = this.details;\n  }\n  if (this.metadata) {\n    status.metadata = this.metadata;\n  }\n  return status;\n};\n\n/**\n * A builder for listener interceptors.\n * @constructor\n */\nfunction ListenerBuilder() {\n  this.metadata = null;\n  this.message = null;\n  this.status = null;\n}\n\n/**\n * Adds an onReceiveMetadata method to the builder.\n * @param {MetadataListener} on_receive_metadata A listener method for\n * receiving metadata.\n * @return {ListenerBuilder}\n */\nListenerBuilder.prototype.withOnReceiveMetadata =\n  function(on_receive_metadata) {\n    this.metadata = on_receive_metadata;\n    return this;\n  };\n\n/**\n * Adds an onReceiveMessage method to the builder.\n * @param {MessageListener} on_receive_message A listener method for receiving\n * messages.\n * @return {ListenerBuilder}\n */\nListenerBuilder.prototype.withOnReceiveMessage = function(on_receive_message) {\n  this.message = on_receive_message;\n  return this;\n};\n\n/**\n * Adds an onReceiveStatus method to the builder.\n * @param {StatusListener} on_receive_status A listener method for receiving\n * status.\n * @return {ListenerBuilder}\n */\nListenerBuilder.prototype.withOnReceiveStatus = function(on_receive_status) {\n  this.status = on_receive_status;\n  return this;\n};\n\n/**\n * Builds the call listener.\n * @return {grpc~Listener}\n */\nListenerBuilder.prototype.build = function() {\n  var self = this;\n  var listener = {};\n  listener.onReceiveMetadata = self.metadata;\n  listener.onReceiveMessage = self.message;\n  listener.onReceiveStatus = self.status;\n  return listener;\n};\n\n/**\n * A builder for the outbound methods of an interceptor.\n * @constructor\n */\nfunction RequesterBuilder() {\n  this.start = null;\n  this.message = null;\n  this.half_close = null;\n  this.cancel = null;\n}\n\n/**\n * Add a metadata requester to the builder.\n * @param {MetadataRequester} start A requester method for handling metadata.\n * @return {RequesterBuilder}\n */\nRequesterBuilder.prototype.withStart = function(start) {\n  this.start = start;\n  return this;\n};\n\n/**\n * Add a message requester to the builder.\n * @param {MessageRequester} send_message A requester method for handling\n * messages.\n * @return {RequesterBuilder}\n */\nRequesterBuilder.prototype.withSendMessage = function(send_message) {\n  this.message = send_message;\n  return this;\n};\n\n/**\n * Add a close requester to the builder.\n * @param {CloseRequester} half_close A requester method for handling client\n * close.\n * @return {RequesterBuilder}\n */\nRequesterBuilder.prototype.withHalfClose = function(half_close) {\n  this.half_close = half_close;\n  return this;\n};\n\n/**\n * Add a cancel requester to the builder.\n * @param {CancelRequester} cancel A requester method for handling `cancel`\n * @return {RequesterBuilder}\n */\nRequesterBuilder.prototype.withCancel = function(cancel) {\n  this.cancel = cancel;\n  return this;\n};\n\n/**\n * Builds the requester's interceptor methods.\n * @return {grpc~Requester}\n */\nRequesterBuilder.prototype.build = function() {\n  var requester = {};\n  requester.start = this.start;\n  requester.sendMessage = this.message;\n  requester.halfClose = this.half_close;\n  requester.cancel = this.cancel;\n  return requester;\n};\n\n/**\n * Transforms a list of interceptor providers into interceptors.\n * @param {InterceptorProvider[]} providers\n * @param {grpc~MethodDefinition} method_definition\n * @return {null|Interceptor[]}\n */\nvar resolveInterceptorProviders = function(providers, method_definition) {\n  if (!Array.isArray(providers)) {\n    return null;\n  }\n  var interceptors = [];\n  for (var i = 0; i < providers.length; i++) {\n    var provider = providers[i];\n    var interceptor = provider(method_definition);\n    if (interceptor) {\n      interceptors.push(interceptor);\n    }\n  }\n  return interceptors;\n};\n\n/**\n * A chainable gRPC call proxy which will delegate to an optional requester\n * object. By default, interceptor methods will chain to next_call. If a\n * requester is provided which implements an interceptor method, that\n * requester method will be executed as part of the chain.\n * @param {InterceptingCall|null} next_call The next call in the chain\n * @param {grpc~Requester=} requester Interceptor methods to handle request\n * operations.\n * @constructor\n */\nfunction InterceptingCall(next_call, requester) {\n  this.next_call = next_call;\n  this.requester = requester;\n}\n\nconst emptyNext = function() {};\n\n/**\n * Get the next method in the chain or a no-op function if we are at the end\n * of the chain\n * @param {string} method_name\n * @return {function} The next method in the chain\n * @private\n */\nInterceptingCall.prototype._getNextCall = function(method_name) {\n  return this.next_call ?\n    this.next_call[method_name].bind(this.next_call) :\n    emptyNext;\n};\n\n/**\n * Call the next method in the chain. This will either be on the next\n * InterceptingCall (next_call), or the requester if the requester\n * implements the method.\n * @param {string} method_name The name of the interceptor method\n * @param {array=} args Payload arguments for the operation\n * @param {function=} next The next InterceptingCall's method\n * @return {null}\n * @private\n */\nInterceptingCall.prototype._callNext = function(method_name, args, next) {\n  var args_array = args || [];\n  var next_call = next ? next : this._getNextCall(method_name);\n  if (this.requester && this.requester[method_name]) {\n    // Avoid using expensive `apply` calls\n    var num_args = args_array.length;\n    switch (num_args) {\n      case 0:\n        return this.requester[method_name](next_call);\n      case 1:\n        return this.requester[method_name](args_array[0], next_call);\n      case 2:\n        return this.requester[method_name](args_array[0], args_array[1],\n                                           next_call);\n    }\n  } else {\n    if (next_call === emptyNext) {\n      throw new Error('Interceptor call chain terminated unexpectedly');\n    }\n    return next_call(args_array[0], args_array[1]);\n  }\n};\n\n/**\n * Starts a call through the outbound interceptor chain and adds an element to\n * the reciprocal inbound listener chain.\n * @param {grpc.Metadata} metadata The outgoing metadata.\n * @param {grpc~Listener} listener An intercepting listener for inbound\n * operations.\n */\nInterceptingCall.prototype.start = function(metadata, listener) {\n  var self = this;\n\n  // If the listener provided is an InterceptingListener, use it. Otherwise, we\n  // must be at the end of the listener chain, and any listener operations\n  // should be terminated in an EndListener.\n  var next_listener = _getInterceptingListener(listener, new EndListener());\n\n  // Build the next method in the interceptor chain\n  var next = function(metadata, current_listener) {\n    // If there is a next call in the chain, run it. Otherwise do nothing.\n    if (self.next_call) {\n      // Wire together any listener provided with the next listener\n      var listener = _getInterceptingListener(current_listener, next_listener);\n      self.next_call.start(metadata, listener);\n    }\n  };\n  this._callNext('start', [metadata, next_listener], next);\n};\n\n/**\n * Pass a message through the interceptor chain.\n * @param {jspb.Message} message\n */\nInterceptingCall.prototype.sendMessage = function(message) {\n  this._callNext('sendMessage', [message]);\n};\n\n/**\n * Run a close operation through the interceptor chain\n */\nInterceptingCall.prototype.halfClose = function() {\n  this._callNext('halfClose');\n};\n\n/**\n * Run a cancel operation through the interceptor chain\n */\nInterceptingCall.prototype.cancel = function() {\n  this._callNext('cancel');\n};\n\n/**\n * Run a cancelWithStatus operation through the interceptor chain.\n * @param {number} code\n * @param {string} details\n */\nInterceptingCall.prototype.cancelWithStatus = function(code, details) {\n  this._callNext('cancelWithStatus', [code, details]);\n};\n\n/**\n * Pass a getPeer call down to the base gRPC call (should not be intercepted)\n * @return {object}\n */\nInterceptingCall.prototype.getPeer = function() {\n  return this._callNext('getPeer');\n};\n\n/**\n * For streaming calls, we need to transparently pass the stream's context\n * through the interceptor chain. Passes the context between InterceptingCalls\n * but hides it from any requester implementations.\n * @param {object} context Carries objects needed for streaming operations.\n * @param {jspb.Message} message The message to send.\n */\nInterceptingCall.prototype.sendMessageWithContext = function(context, message) {\n  var next = this.next_call ?\n    this.next_call.sendMessageWithContext.bind(this.next_call, context) :\n    context;\n  this._callNext('sendMessage', [message], next);\n};\n\n/**\n * For receiving streaming messages, we need to seed the base interceptor with\n * the streaming context to create a RECV_MESSAGE batch.\n * @param {object} context Carries objects needed for streaming operations\n */\nInterceptingCall.prototype.recvMessageWithContext = function(context) {\n  this._callNext('recvMessageWithContext', [context]);\n};\n\n/**\n * A chain-able listener object which will delegate to a custom listener when\n * appropriate.\n * @param {InterceptingListener|null} next_listener The next\n * InterceptingListener in the chain\n * @param {grpc~Listener=} delegate A custom listener object which may implement\n * specific operations\n * @constructor\n */\nfunction InterceptingListener(next_listener, delegate) {\n  this.delegate = delegate || {};\n  this.next_listener = next_listener;\n}\n\n/**\n * Get the next method in the chain or a no-op function if we are at the end\n * of the chain.\n * @param {string} method_name The name of the listener method.\n * @return {function} The next method in the chain\n * @private\n */\nInterceptingListener.prototype._getNextListener = function(method_name) {\n  return this.next_listener ?\n    this.next_listener[method_name].bind(this.next_listener) :\n    function(){};\n};\n\n/**\n * Call the next method in the chain. This will either be on the next\n * InterceptingListener (next_listener), or the requester if the requester\n * implements the method.\n * @param {string} method_name The name of the interceptor method\n * @param {array=} args Payload arguments for the operation\n * @param {function=} next The next InterceptingListener's method\n * @return {null}\n * @private\n */\nInterceptingListener.prototype._callNext = function(method_name, args, next) {\n  var args_array = args || [];\n  var next_listener = next ? next : this._getNextListener(method_name);\n  if (this.delegate && this.delegate[method_name]) {\n    // Avoid using expensive `apply` calls\n    var num_args = args_array.length;\n    switch (num_args) {\n      case 0:\n        return this.delegate[method_name](next_listener);\n      case 1:\n        return this.delegate[method_name](args_array[0], next_listener);\n      case 2:\n        return this.delegate[method_name](args_array[0], args_array[1],\n                                          next_listener);\n    }\n  } else {\n    return next_listener(args_array[0], args_array[1]);\n  }\n};\n/**\n * Inbound metadata receiver.\n * @param {Metadata} metadata\n */\nInterceptingListener.prototype.onReceiveMetadata = function(metadata) {\n  this._callNext('onReceiveMetadata', [metadata]);\n};\n\n/**\n * Inbound message receiver.\n * @param {jspb.Message} message\n */\nInterceptingListener.prototype.onReceiveMessage = function(message) {\n  this._callNext('onReceiveMessage', [message]);\n};\n\n/**\n * When intercepting streaming message, we need to pass the streaming context\n * transparently along the chain. Hides the context from the delegate listener\n * methods.\n * @param {object} context Carries objects needed for streaming operations.\n * @param {jspb.Message} message The message received.\n */\nInterceptingListener.prototype.recvMessageWithContext = function(context,\n                                                                 message) {\n  var fallback = this.next_listener.recvMessageWithContext;\n  var next_method = this.next_listener ?\n    fallback.bind(this.next_listener, context) :\n    context;\n  if (this.delegate.onReceiveMessage) {\n    this.delegate.onReceiveMessage(message, next_method, context);\n  } else {\n    next_method(message);\n  }\n};\n\n/**\n * Inbound status receiver.\n * @param {grpc~StatusObject} status\n */\nInterceptingListener.prototype.onReceiveStatus = function(status) {\n  this._callNext('onReceiveStatus', [status]);\n};\n\n/**\n * A dead-end listener used to terminate a call chain. Used when an interceptor\n * creates a branch chain, when the branch returns the listener chain will\n * terminate here.\n * @constructor\n */\nfunction EndListener() {}\nEndListener.prototype.onReceiveMetadata = function(){};\nEndListener.prototype.onReceiveMessage = function(){};\nEndListener.prototype.onReceiveStatus = function(){};\nEndListener.prototype.recvMessageWithContext = function(){};\n\n/**\n * Get a call object built with the provided options.\n * @param {grpc.Channel} channel\n * @param {string} path\n * @param {grpc.Client~CallOptions=} options Options object.\n */\nfunction getCall(channel, path, options) {\n  var deadline;\n  var host;\n  var parent;\n  var propagate_flags;\n  var credentials;\n  if (options) {\n    deadline = options.deadline;\n    host = options.host;\n    parent = options.parent ? options.parent.call : undefined;\n    propagate_flags = options.propagate_flags;\n    credentials = options.credentials;\n  }\n  if (deadline === undefined) {\n    deadline = Infinity;\n  }\n  var call = channel.createCall(path, deadline, host,\n                                parent, propagate_flags);\n  if (credentials) {\n    call.setCredentials(credentials);\n  }\n  return call;\n}\n\nvar OP_DEPENDENCIES = {\n  [grpc.opType.SEND_MESSAGE]: [grpc.opType.SEND_INITIAL_METADATA],\n  [grpc.opType.SEND_CLOSE_FROM_CLIENT]: [grpc.opType.SEND_MESSAGE],\n  [grpc.opType.RECV_MESSAGE]: [grpc.opType.SEND_INITIAL_METADATA]\n};\n\n/**\n * Produces a callback triggered by streaming response messages.\n * @private\n * @param {EventEmitter} emitter\n * @param {grpc.internal~Call} call\n * @param {function} get_listener Returns a grpc~Listener.\n * @param {grpc~deserialize} deserialize\n * @return {Function}\n */\nfunction _getStreamReadCallback(emitter, call, get_listener, deserialize) {\n  return function (err, response) {\n    if (err) {\n      // Something has gone wrong. Stop reading and wait for status\n      emitter.finished = true;\n      emitter._readsDone();\n      return;\n    }\n    var data = response.read;\n    var deserialized;\n    try {\n      deserialized = deserialize(data);\n    } catch (e) {\n      common.log(constants.logVerbosity.ERROR, `Response deserialization failed: ${e.message}`);\n      emitter._readsDone({\n        code: constants.status.INTERNAL,\n        details: 'Failed to parse server response'\n      });\n      return;\n    }\n    if (data === null) {\n      emitter._readsDone();\n      return;\n    }\n    var listener = get_listener();\n    var context = {\n      call: call,\n      listener: listener\n    };\n    listener.recvMessageWithContext(context, deserialized);\n  };\n}\n\n/**\n * Tests whether a batch can be started.\n * @private\n * @param {number[]} batch_ops The operations in the batch we are checking.\n * @param {number[]} completed_ops Previously completed operations.\n * @return {boolean}\n */\nfunction _areBatchRequirementsMet(batch_ops, completed_ops) {\n  var dependencies = common.flatMap(batch_ops, function(op) {\n    return OP_DEPENDENCIES[op] || [];\n  });\n  for (var i = 0; i < dependencies.length; i++) {\n    var required_dep = dependencies[i];\n    if (batch_ops.indexOf(required_dep) === -1 &&\n        completed_ops.indexOf(required_dep) === -1) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Enforces the order of operations for synchronous requests. If a batch's\n * operations cannot be started because required operations have not started\n * yet, the batch is deferred until requirements are met.\n * @private\n * @param {grpc.Client~Call} call\n * @param {object} batch\n * @param {object} batch_state\n * @param {number[]} [batch_state.completed_ops] The ops already sent.\n * @param {object} [batch_state.deferred_batches] Batches to be sent after\n *     their dependencies are fulfilled.\n * @param {function} callback\n * @return {object}\n */\nfunction _startBatchIfReady(call, batch, batch_state, callback) {\n  var completed_ops = batch_state.completed_ops;\n  var deferred_batches = batch_state.deferred_batches;\n  var batch_ops = Object.keys(batch).map(Number);\n  if (_areBatchRequirementsMet(batch_ops, completed_ops)) {\n    // Dependencies are met, start the batch and any deferred batches whose\n    // dependencies are met as a result.\n    call.startBatch(batch, callback);\n    completed_ops = Array.from(new Set(completed_ops.concat(batch_ops)));\n    deferred_batches = common.flatMap(deferred_batches, function(deferred_batch) {\n      var deferred_batch_ops = Object.keys(deferred_batch).map(Number);\n      if (_areBatchRequirementsMet(deferred_batch_ops, completed_ops)) {\n        call.startBatch(deferred_batch.batch, deferred_batch.callback);\n        return [];\n      }\n      return [deferred_batch];\n    });\n  } else {\n    // Dependencies are not met, defer the batch\n    deferred_batches = deferred_batches.concat({\n      batch: batch,\n      callback: callback\n    });\n  }\n  return {\n    completed_ops: completed_ops,\n    deferred_batches: deferred_batches\n  };\n}\n\n/**\n * Produces an interceptor which will start gRPC batches for unary calls.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Channel} channel\n * @param {EventEmitter} emitter\n * @param {function} callback\n * @return {Interceptor}\n */\nfunction _getUnaryInterceptor(method_definition, channel, emitter, callback) {\n  var serialize = method_definition.requestSerialize;\n  var deserialize = method_definition.responseDeserialize;\n  return function (options) {\n    var call = getCall(channel, method_definition.path, options);\n    var first_listener;\n    var final_requester = {};\n    var batch_state = {\n      completed_ops: [],\n      deferred_batches: []\n    };\n    final_requester.start = function (metadata, listener) {\n      var batch = {\n        [grpc.opType.SEND_INITIAL_METADATA]:\n          metadata._getCoreRepresentation(),\n      };\n      first_listener = listener;\n      batch_state = _startBatchIfReady(call, batch, batch_state,\n                                       function() {});\n    };\n    final_requester.sendMessage = function (message) {\n      var batch = {\n        [grpc.opType.SEND_MESSAGE]: serialize(message),\n      };\n      batch_state = _startBatchIfReady(call, batch, batch_state,\n                                         function() {});\n    };\n    final_requester.halfClose = function () {\n      var batch = {\n        [grpc.opType.SEND_CLOSE_FROM_CLIENT]: true,\n        [grpc.opType.RECV_INITIAL_METADATA]: true,\n        [grpc.opType.RECV_MESSAGE]: true,\n        [grpc.opType.RECV_STATUS_ON_CLIENT]: true\n      };\n      var callback = function (err, response) {\n        response.status.metadata = Metadata._fromCoreRepresentation(\n          response.status.metadata);\n        var status = response.status;\n        var deserialized;\n        if (status.code === constants.status.OK) {\n          if (err) {\n            // Got a batch error, but OK status. Something went wrong\n            callback(err);\n            return;\n          } else {\n            try {\n              deserialized = deserialize(response.read);\n            } catch (e) {\n              common.log(constants.logVerbosity.ERROR, `Response deserialization failed: ${e.message}`);\n              /* Change status to indicate bad server response. This\n               * will result in passing an error to the callback */\n              status = {\n                code: constants.status.INTERNAL,\n                details: 'Failed to parse server response'\n              };\n            }\n          }\n        }\n        response.metadata =\n          Metadata._fromCoreRepresentation(response.metadata);\n        first_listener.onReceiveMetadata(response.metadata);\n        first_listener.onReceiveMessage(deserialized);\n        first_listener.onReceiveStatus(status);\n      };\n      batch_state = _startBatchIfReady(call, batch, batch_state, callback);\n    };\n    final_requester.cancel = function () {\n      call.cancel();\n    };\n    final_requester.cancelWithStatus = function(code, details) {\n      call.cancelWithStatus(code, details)\n    };\n    final_requester.getPeer = function () {\n      return call.getPeer();\n    };\n    return new InterceptingCall(null, final_requester);\n  };\n}\n\n/**\n * Produces an interceptor which will start gRPC batches for client streaming\n * calls.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Channel} channel\n * @param {EventEmitter} emitter\n * @param {function} callback\n * @return {Interceptor}\n */\nfunction _getClientStreamingInterceptor(method_definition, channel, emitter,\n  callback) {\n  var serialize = common.wrapIgnoreNull(method_definition.requestSerialize);\n  var deserialize = method_definition.responseDeserialize;\n  return function (options) {\n    var first_listener;\n    var call = getCall(channel, method_definition.path, options);\n    var final_requester = {};\n    final_requester.start = function (metadata, listener) {\n      var metadata_batch = {\n        [grpc.opType.SEND_INITIAL_METADATA]: metadata._getCoreRepresentation(),\n        [grpc.opType.RECV_INITIAL_METADATA]: true\n      };\n      first_listener = listener;\n      call.startBatch(metadata_batch, function (err, response) {\n        if (err) {\n          // The call has stopped for some reason. A non-OK status will arrive\n          // in the other batch.\n          return;\n        }\n        response.metadata = Metadata._fromCoreRepresentation(response.metadata);\n        listener.onReceiveMetadata(response.metadata);\n      });\n      var recv_batch = {};\n      recv_batch[grpc.opType.RECV_MESSAGE] = true;\n      recv_batch[grpc.opType.RECV_STATUS_ON_CLIENT] = true;\n      call.startBatch(recv_batch, function (err, response) {\n        response.status.metadata = Metadata._fromCoreRepresentation(\n          response.status.metadata);\n        var status = response.status;\n        var deserialized;\n        if (status.code === constants.status.OK) {\n          if (err) {\n            // Got a batch error, but OK status. Something went wrong\n            callback(err);\n            return;\n          } else {\n            try {\n              deserialized = deserialize(response.read);\n            } catch (e) {\n              common.log(constants.logVerbosity.ERROR, `Response deserialization failed: ${e.message}`);\n              /* Change status to indicate bad server response. This will result\n               * in passing an error to the callback */\n              status = {\n                code: constants.status.INTERNAL,\n                details: 'Failed to parse server response'\n              };\n            }\n          }\n        }\n        listener.onReceiveMessage(deserialized);\n        listener.onReceiveStatus(status);\n      });\n    };\n    final_requester.sendMessage = function (chunk, context) {\n      var message;\n      var callback = (context && context.callback) ?\n        context.callback :\n        function () { };\n      var encoding = (context && context.encoding) ?\n        context.encoding :\n        '';\n      try {\n        message = serialize(chunk);\n      } catch (e) {\n        common.log(constants.logVerbosity.ERROR, `Request serialization failed: ${e.message}`);\n        /* Sending this error to the server and emitting it immediately on the\n           client may put the call in a slightly weird state on the client side,\n           but passing an object that causes a serialization failure is a misuse\n           of the API anyway, so that's OK. The primary purpose here is to give\n           the programmer a useful error and to stop the stream properly */\n        call.cancelWithStatus(constants.status.INTERNAL,\n          'Serialization failure');\n        callback(e);\n        return;\n      }\n      if (Number.isFinite(encoding)) {\n        /* Attach the encoding if it is a finite number. This is the closest we\n         * can get to checking that it is valid flags */\n        message.grpcWriteFlags = encoding;\n      }\n      var batch = {\n        [grpc.opType.SEND_MESSAGE]: message\n      };\n      call.startBatch(batch, function (err, event) {\n        callback(err, event);\n      });\n    };\n    final_requester.halfClose = function () {\n      var batch = {\n        [grpc.opType.SEND_CLOSE_FROM_CLIENT]: true\n      };\n      call.startBatch(batch, function () { });\n    };\n    final_requester.cancel = function () {\n      call.cancel();\n    };\n    final_requester.cancelWithStatus = function(code, details) {\n      call.cancelWithStatus(code, details)\n    };\n    final_requester.getPeer = function() {\n      return call.getPeer();\n    };\n    return new InterceptingCall(null, final_requester);\n  };\n}\n\n/**\n * Produces an interceptor which will start gRPC batches for server streaming\n * calls.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Channel} channel\n * @param {EventEmitter} emitter\n * @return {Interceptor}\n */\nfunction _getServerStreamingInterceptor(method_definition, channel, emitter) {\n  var deserialize = common.wrapIgnoreNull(\n    method_definition.responseDeserialize);\n  var serialize = method_definition.requestSerialize;\n  return function (options) {\n    var batch_state = {\n      completed_ops: [],\n      deferred_batches: []\n    };\n    var call = getCall(channel, method_definition.path, options);\n    var final_requester = {};\n    var first_listener;\n    var get_listener = function() {\n      return first_listener;\n    };\n    final_requester.start = function(metadata, listener) {\n      first_listener = listener;\n      metadata = metadata.clone();\n      var metadata_batch = {\n        [grpc.opType.SEND_INITIAL_METADATA]: metadata._getCoreRepresentation(),\n        [grpc.opType.RECV_INITIAL_METADATA]: true\n      };\n      var callback = function(err, response) {\n        if (err) {\n          // The call has stopped for some reason. A non-OK status will arrive\n          // in the other batch.\n          return;\n        }\n        first_listener.onReceiveMetadata(\n          Metadata._fromCoreRepresentation(response.metadata));\n      };\n      batch_state = _startBatchIfReady(call, metadata_batch, batch_state,\n                                       callback);\n      var status_batch = {\n        [grpc.opType.RECV_STATUS_ON_CLIENT]: true\n      };\n      call.startBatch(status_batch, function(err, response) {\n        if (err) {\n          emitter.emit('error', err);\n          return;\n        }\n        response.status.metadata = Metadata._fromCoreRepresentation(\n          response.status.metadata);\n        first_listener.onReceiveStatus(response.status);\n      });\n    };\n    final_requester.sendMessage = function(argument) {\n      var message = serialize(argument);\n      if (options) {\n        message.grpcWriteFlags = options.flags;\n      }\n      var send_batch = {\n        [grpc.opType.SEND_MESSAGE]: message\n      };\n      var callback = function(err, response) {\n        if (err) {\n          // The call has stopped for some reason. A non-OK status will arrive\n          // in the other batch.\n          return;\n        }\n      };\n      batch_state = _startBatchIfReady(call, send_batch, batch_state, callback);\n    };\n    final_requester.halfClose = function() {\n      var batch = {\n        [grpc.opType.SEND_CLOSE_FROM_CLIENT]: true\n      };\n      batch_state = _startBatchIfReady(call, batch, batch_state, function() {});\n    };\n    final_requester.recvMessageWithContext = function(context) {\n      var recv_batch = {\n        [grpc.opType.RECV_MESSAGE]: true\n      };\n      var callback = _getStreamReadCallback(emitter, call,\n        get_listener, deserialize);\n      batch_state = _startBatchIfReady(call, recv_batch, batch_state, callback);\n    };\n    final_requester.cancel = function() {\n      call.cancel();\n    };\n    final_requester.cancelWithStatus = function(code, details) {\n      call.cancelWithStatus(code, details)\n    };\n    final_requester.getPeer = function() {\n      return call.getPeer();\n    };\n    return new InterceptingCall(null, final_requester);\n  };\n}\n\n/**\n * Produces an interceptor which will start gRPC batches for bi-directional\n * calls.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Channel} channel\n * @param {EventEmitter} emitter\n * @return {Interceptor}\n */\nfunction _getBidiStreamingInterceptor(method_definition, channel, emitter) {\n  var serialize = common.wrapIgnoreNull(method_definition.requestSerialize);\n  var deserialize = common.wrapIgnoreNull(\n    method_definition.responseDeserialize);\n  return function (options) {\n    var first_listener;\n    var get_listener = function() {\n      return first_listener;\n    };\n    var call = getCall(channel, method_definition.path, options);\n    var final_requester = {};\n    final_requester.start = function (metadata, listener) {\n      var metadata_batch = {\n        [grpc.opType.SEND_INITIAL_METADATA]: metadata._getCoreRepresentation(),\n        [grpc.opType.RECV_INITIAL_METADATA]: true\n      };\n      first_listener = listener;\n      call.startBatch(metadata_batch, function (err, response) {\n        if (err) {\n          // The call has stopped for some reason. A non-OK status will arrive\n          // in the other batch.\n          return;\n        }\n        response.metadata = Metadata._fromCoreRepresentation(response.metadata);\n        listener.onReceiveMetadata(response.metadata);\n      });\n      var recv_batch = {};\n      recv_batch[grpc.opType.RECV_STATUS_ON_CLIENT] = true;\n      call.startBatch(recv_batch, function (err, response) {\n        var status = response.status;\n        if (status.code === constants.status.OK) {\n          if (err) {\n            emitter.emit('error', err);\n            return;\n          }\n        }\n        response.status.metadata = Metadata._fromCoreRepresentation(\n          response.status.metadata);\n        listener.onReceiveStatus(status);\n      });\n    };\n    final_requester.sendMessage = function (chunk, context) {\n      var message;\n      var callback = (context && context.callback) ?\n        context.callback :\n        function() {};\n      var encoding = (context && context.encoding) ?\n        context.encoding :\n        '';\n      try {\n        message = serialize(chunk);\n      } catch (e) {\n        common.log(constants.logVerbosity.ERROR, `Request serialization failed: ${e.message}`);\n        /* Sending this error to the server and emitting it immediately on the\n           client may put the call in a slightly weird state on the client side,\n           but passing an object that causes a serialization failure is a misuse\n           of the API anyway, so that's OK. The primary purpose here is to give\n           the programmer a useful error and to stop the stream properly */\n        call.cancelWithStatus(constants.status.INTERNAL,\n          'Serialization failure');\n        callback(e);\n        return;\n      }\n      if (Number.isFinite(encoding)) {\n        /* Attach the encoding if it is a finite number. This is the closest we\n         * can get to checking that it is valid flags */\n        message.grpcWriteFlags = encoding;\n      }\n      var batch = {\n        [grpc.opType.SEND_MESSAGE]: message\n      };\n      call.startBatch(batch, function (err, event) {\n        callback(err, event);\n      });\n    };\n    final_requester.halfClose = function () {\n      var batch = {\n        [grpc.opType.SEND_CLOSE_FROM_CLIENT]: true\n      };\n      call.startBatch(batch, function () { });\n    };\n    final_requester.recvMessageWithContext = function(context) {\n      var recv_batch = {\n        [grpc.opType.RECV_MESSAGE]: true\n      };\n      call.startBatch(recv_batch, _getStreamReadCallback(emitter, call,\n        get_listener, deserialize));\n    };\n    final_requester.cancel = function() {\n      call.cancel();\n    };\n    final_requester.cancelWithStatus = function(code, details) {\n      call.cancelWithStatus(code, details)\n    };\n    final_requester.getPeer = function() {\n      return call.getPeer();\n    };\n    return new InterceptingCall(null, final_requester);\n  };\n}\n\n/**\n * Produces a listener for responding to callers of unary RPCs.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {EventEmitter} emitter\n * @param {function} callback\n * @return {grpc~Listener}\n */\nfunction _getUnaryListener(method_definition, emitter, callback) {\n  var resultMessage;\n  return {\n    onReceiveMetadata: function (metadata) {\n      emitter.emit('metadata', metadata);\n    },\n    onReceiveMessage: function (message) {\n      resultMessage = message;\n    },\n    onReceiveStatus: function (status) {\n      if (status.code !== constants.status.OK) {\n        var error = common.createStatusError(status);\n        callback(error);\n      } else {\n        callback(null, resultMessage);\n      }\n      emitter.emit('status', status);\n    }\n  };\n}\n\n/**\n * Produces a listener for responding to callers of client streaming RPCs.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {EventEmitter} emitter\n * @param {function} callback\n * @return {grpc~Listener}\n */\nfunction _getClientStreamingListener(method_definition, emitter, callback) {\n  var resultMessage;\n  return {\n    onReceiveMetadata: function (metadata) {\n      emitter.emit('metadata', metadata);\n    },\n    onReceiveMessage: function (message) {\n      resultMessage = message;\n    },\n    onReceiveStatus: function (status) {\n      if (status.code !== constants.status.OK) {\n        var error = common.createStatusError(status);\n        callback(error);\n      } else {\n        callback(null, resultMessage);\n      }\n      emitter.emit('status', status);\n    }\n  };\n}\n\n/**\n * Produces a listener for responding to callers of server streaming RPCs.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {EventEmitter} emitter\n * @return {grpc~Listener}\n */\nfunction _getServerStreamingListener(method_definition, emitter) {\n  var deserialize = common.wrapIgnoreNull(\n    method_definition.responseDeserialize);\n  return {\n    onReceiveMetadata: function (metadata) {\n      emitter.emit('metadata', metadata);\n    },\n    onReceiveMessage: function(message, next, context) {\n      if (emitter.push(message) && message !== null) {\n        var call = context.call;\n        var get_listener = function() {\n          return context.listener;\n        };\n        var read_batch = {};\n        read_batch[grpc.opType.RECV_MESSAGE] = true;\n        call.startBatch(read_batch, _getStreamReadCallback(emitter, call,\n          get_listener, deserialize));\n      } else {\n        emitter.reading = false;\n      }\n    },\n    onReceiveStatus: function (status) {\n      emitter._receiveStatus(status);\n    }\n  };\n}\n\n/**\n * Produces a listener for responding to callers of bi-directional RPCs.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {EventEmitter} emitter\n * @return {grpc~Listener}\n */\nfunction _getBidiStreamingListener(method_definition, emitter) {\n  var deserialize = common.wrapIgnoreNull(\n    method_definition.responseDeserialize);\n  return {\n    onReceiveMetadata: function (metadata) {\n      emitter.emit('metadata', metadata);\n    },\n    onReceiveMessage: function(message, next, context) {\n      if (emitter.push(message) && message !== null) {\n        var call = context.call;\n        var get_listener = function() {\n          return context.listener;\n        };\n        var read_batch = {};\n        read_batch[grpc.opType.RECV_MESSAGE] = true;\n        call.startBatch(read_batch, _getStreamReadCallback(emitter, call,\n          get_listener, deserialize));\n      } else {\n        emitter.reading = false;\n      }\n    },\n    onReceiveStatus: function (status) {\n      emitter._receiveStatus(status);\n    }\n  };\n}\n\nvar interceptorGenerators = {\n  [methodTypes.UNARY]: _getUnaryInterceptor,\n  [methodTypes.CLIENT_STREAMING]: _getClientStreamingInterceptor,\n  [methodTypes.SERVER_STREAMING]: _getServerStreamingInterceptor,\n  [methodTypes.BIDI_STREAMING]: _getBidiStreamingInterceptor\n};\n\nvar listenerGenerators = {\n  [methodTypes.UNARY]: _getUnaryListener,\n  [methodTypes.CLIENT_STREAMING]: _getClientStreamingListener,\n  [methodTypes.SERVER_STREAMING]: _getServerStreamingListener,\n  [methodTypes.BIDI_STREAMING]: _getBidiStreamingListener\n};\n\n/**\n * Creates the last listener in an interceptor stack.\n * @param {grpc~MethodDefinition} method_definition\n * @param {EventEmitter} emitter\n * @param {function=} callback\n * @return {grpc~Listener}\n */\nfunction getLastListener(method_definition, emitter, callback) {\n  if (typeof emitter === 'function') {\n    callback = emitter;\n    callback = function() {};\n  }\n  if (typeof callback !== 'function') {\n    callback = function() {};\n  }\n  if (!((emitter instanceof EventEmitter) &&\n       (typeof callback === 'function'))) {\n    throw new Error('Argument mismatch in getLastListener');\n  }\n  var method_type = common.getMethodType(method_definition);\n  var generator = listenerGenerators[method_type];\n  return generator(method_definition, emitter, callback);\n}\n\n/**\n *\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Client~CallOptions} options\n * @param {Interceptor[]} interceptors\n * @param {grpc.Channel} channel\n * @param {function|EventEmitter} responder\n */\nfunction getInterceptingCall(method_definition, options,\n                             interceptors, channel, responder) {\n  var last_interceptor = _getLastInterceptor(method_definition, channel,\n                                            responder);\n  var all_interceptors = interceptors.concat(last_interceptor);\n  return _buildChain(all_interceptors, options);\n}\n\n/**\n * Creates the last interceptor in an interceptor stack.\n * @private\n * @param {grpc~MethodDefinition} method_definition\n * @param {grpc.Channel} channel\n * @param {function|EventEmitter} responder\n * @return {Interceptor}\n */\nfunction _getLastInterceptor(method_definition, channel, responder) {\n  var callback = typeof responder === 'function' ? responder : function() {};\n  var emitter = (responder instanceof EventEmitter) ? responder :\n                                                      new EventEmitter();\n  var method_type = common.getMethodType(method_definition);\n  var generator = interceptorGenerators[method_type];\n  return generator(method_definition, channel, emitter, callback);\n}\n\n/**\n * Chain a list of interceptors together and return the first InterceptingCall.\n * @private\n * @param {Interceptor[]} interceptors An interceptor stack.\n * @param {grpc.Client~CallOptions} options Call options.\n * @return {InterceptingCall}\n */\nfunction _buildChain(interceptors, options) {\n  var next = function(interceptors) {\n    if (interceptors.length === 0) {\n      return function (options) {};\n    }\n    var head_interceptor = interceptors[0];\n    var rest_interceptors = interceptors.slice(1);\n    return function (options) {\n      return head_interceptor(options, next(rest_interceptors));\n    };\n  };\n  var chain = next(interceptors)(options);\n  return new InterceptingCall(chain);\n}\n\n/**\n * Wraps a plain listener object in an InterceptingListener if it isn't an\n * InterceptingListener already.\n * @param {InterceptingListener|object|null} current_listener\n * @param {InterceptingListener|EndListener} next_listener\n * @return {InterceptingListener|null}\n * @private\n */\nfunction _getInterceptingListener(current_listener, next_listener) {\n  if (!_isInterceptingListener(current_listener)) {\n    return new InterceptingListener(next_listener, current_listener);\n  }\n  return current_listener;\n}\n\n/**\n * Test if the listener exists and is an InterceptingListener.\n * @param listener\n * @return {boolean}\n * @private\n */\nfunction _isInterceptingListener(listener) {\n  return listener && listener.constructor.name === 'InterceptingListener';\n}\n\nexports.resolveInterceptorProviders = resolveInterceptorProviders;\n\nexports.InterceptingCall = InterceptingCall;\nexports.ListenerBuilder = ListenerBuilder;\nexports.RequesterBuilder = RequesterBuilder;\nexports.StatusBuilder = StatusBuilder;\n\nexports.InterceptorConfigurationError = InterceptorConfigurationError;\n\nexports.getInterceptingCall = getInterceptingCall;\nexports.getLastListener = getLastListener;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA,IAAIA,IAAI,GAAGC,OAAO,CAAC,kBAAD,CAAlB;;AACA,IAAIC,QAAQ,GAAGD,OAAO,CAAC,YAAD,CAAtB;;AACA,IAAIE,SAAS,GAAGF,OAAO,CAAC,aAAD,CAAvB;;AACA,IAAIG,MAAM,GAAGH,OAAO,CAAC,UAAD,CAApB;;AACA,IAAII,WAAW,GAAGF,SAAS,CAACE,WAA5B;;AACA,IAAIC,YAAY,GAAGL,OAAO,CAAC,QAAD,CAAP,CAAkBK,YAArC;AAEA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAIC,6BAA6B,GAC/B,SAASA,6BAAT,CAAuCC,OAAvC,EAAgDC,KAAhD,EAAuD;EACrDC,KAAK,CAACC,iBAAN,CAAwB,IAAxB,EAA8B,KAAKC,WAAnC;EACA,KAAKC,IAAL,GAAY,KAAKD,WAAL,CAAiBC,IAA7B;EACA,KAAKL,OAAL,GAAeA,OAAf;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"},"metadata":{},"sourceType":"script"}