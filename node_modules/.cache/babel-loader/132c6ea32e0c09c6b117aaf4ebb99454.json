{"ast":null,"code":"'use strict';\n\nconst proc = typeof process === 'object' && process ? process : {\n  stdout: null,\n  stderr: null\n};\n\nconst EE = require('events');\n\nconst Stream = require('stream');\n\nconst SD = require('string_decoder').StringDecoder;\n\nconst EOF = Symbol('EOF');\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd');\nconst EMITTED_END = Symbol('emittedEnd');\nconst EMITTING_END = Symbol('emittingEnd');\nconst EMITTED_ERROR = Symbol('emittedError');\nconst CLOSED = Symbol('closed');\nconst READ = Symbol('read');\nconst FLUSH = Symbol('flush');\nconst FLUSHCHUNK = Symbol('flushChunk');\nconst ENCODING = Symbol('encoding');\nconst DECODER = Symbol('decoder');\nconst FLOWING = Symbol('flowing');\nconst PAUSED = Symbol('paused');\nconst RESUME = Symbol('resume');\nconst BUFFER = Symbol('buffer');\nconst PIPES = Symbol('pipes');\nconst BUFFERLENGTH = Symbol('bufferLength');\nconst BUFFERPUSH = Symbol('bufferPush');\nconst BUFFERSHIFT = Symbol('bufferShift');\nconst OBJECTMODE = Symbol('objectMode');\nconst DESTROYED = Symbol('destroyed');\nconst EMITDATA = Symbol('emitData');\nconst EMITEND = Symbol('emitEnd');\nconst EMITEND2 = Symbol('emitEnd2');\nconst ASYNC = Symbol('async');\n\nconst defer = fn => Promise.resolve().then(fn); // TODO remove when Node v8 support drops\n\n\nconst doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== '1';\nconst ASYNCITERATOR = doIter && Symbol.asyncIterator || Symbol('asyncIterator not implemented');\nconst ITERATOR = doIter && Symbol.iterator || Symbol('iterator not implemented'); // events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\n\nconst isEndish = ev => ev === 'end' || ev === 'finish' || ev === 'prefinish';\n\nconst isArrayBuffer = b => b instanceof ArrayBuffer || typeof b === 'object' && b.constructor && b.constructor.name === 'ArrayBuffer' && b.byteLength >= 0;\n\nconst isArrayBufferView = b => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);\n\nclass Pipe {\n  constructor(src, dest, opts) {\n    this.src = src;\n    this.dest = dest;\n    this.opts = opts;\n\n    this.ondrain = () => src[RESUME]();\n\n    dest.on('drain', this.ondrain);\n  }\n\n  unpipe() {\n    this.dest.removeListener('drain', this.ondrain);\n  } // istanbul ignore next - only here for the prototype\n\n\n  proxyErrors() {}\n\n  end() {\n    this.unpipe();\n    if (this.opts.end) this.dest.end();\n  }\n\n}\n\nclass PipeProxyErrors extends Pipe {\n  unpipe() {\n    this.src.removeListener('error', this.proxyErrors);\n    super.unpipe();\n  }\n\n  constructor(src, dest, opts) {\n    super(src, dest, opts);\n\n    this.proxyErrors = er => dest.emit('error', er);\n\n    src.on('error', this.proxyErrors);\n  }\n\n}\n\nmodule.exports = class Minipass extends Stream {\n  constructor(options) {\n    super();\n    this[FLOWING] = false; // whether we're explicitly paused\n\n    this[PAUSED] = false;\n    this[PIPES] = [];\n    this[BUFFER] = [];\n    this[OBJECTMODE] = options && options.objectMode || false;\n    if (this[OBJECTMODE]) this[ENCODING] = null;else this[ENCODING] = options && options.encoding || null;\n    if (this[ENCODING] === 'buffer') this[ENCODING] = null;\n    this[ASYNC] = options && !!options.async || false;\n    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;\n    this[EOF] = false;\n    this[EMITTED_END] = false;\n    this[EMITTING_END] = false;\n    this[CLOSED] = false;\n    this[EMITTED_ERROR] = null;\n    this.writable = true;\n    this.readable = true;\n    this[BUFFERLENGTH] = 0;\n    this[DESTROYED] = false;\n\n    if (options && options.debugExposeBuffer === true) {\n      Object.defineProperty(this, 'buffer', {\n        get: () => this[BUFFER]\n      });\n    }\n\n    if (options && options.debugExposePipes === true) {\n      Object.defineProperty(this, 'pipes', {\n        get: () => this[PIPES]\n      });\n    }\n  }\n\n  get bufferLength() {\n    return this[BUFFERLENGTH];\n  }\n\n  get encoding() {\n    return this[ENCODING];\n  }\n\n  set encoding(enc) {\n    if (this[OBJECTMODE]) throw new Error('cannot set encoding in objectMode');\n    if (this[ENCODING] && enc !== this[ENCODING] && (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH])) throw new Error('cannot change encoding');\n\n    if (this[ENCODING] !== enc) {\n      this[DECODER] = enc ? new SD(enc) : null;\n      if (this[BUFFER].length) this[BUFFER] = this[BUFFER].map(chunk => this[DECODER].write(chunk));\n    }\n\n    this[ENCODING] = enc;\n  }\n\n  setEncoding(enc) {\n    this.encoding = enc;\n  }\n\n  get objectMode() {\n    return this[OBJECTMODE];\n  }\n\n  set objectMode(om) {\n    this[OBJECTMODE] = this[OBJECTMODE] || !!om;\n  }\n\n  get ['async']() {\n    return this[ASYNC];\n  }\n\n  set ['async'](a) {\n    this[ASYNC] = this[ASYNC] || !!a;\n  }\n\n  write(chunk, encoding, cb) {\n    if (this[EOF]) throw new Error('write after end');\n\n    if (this[DESTROYED]) {\n      this.emit('error', Object.assign(new Error('Cannot call write after a stream was destroyed'), {\n        code: 'ERR_STREAM_DESTROYED'\n      }));\n      return true;\n    }\n\n    if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';\n    if (!encoding) encoding = 'utf8';\n    const fn = this[ASYNC] ? defer : f => f(); // convert array buffers and typed array views into buffers\n    // at some point in the future, we may want to do the opposite!\n    // leave strings and buffers as-is\n    // anything else switches us into object mode\n\n    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n      if (isArrayBufferView(chunk)) chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);else if (isArrayBuffer(chunk)) chunk = Buffer.from(chunk);else if (typeof chunk !== 'string') // use the setter so we throw if we have encoding set\n        this.objectMode = true;\n    } // handle object mode up front, since it's simpler\n    // this yields better performance, fewer checks later.\n\n\n    if (this[OBJECTMODE]) {\n      /* istanbul ignore if - maybe impossible? */\n      if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);\n      if (this.flowing) this.emit('data', chunk);else this[BUFFERPUSH](chunk);\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable');\n      if (cb) fn(cb);\n      return this.flowing;\n    } // at this point the chunk is a buffer or string\n    // don't buffer it up or send it to the decoder\n\n\n    if (!chunk.length) {\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable');\n      if (cb) fn(cb);\n      return this.flowing;\n    } // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n\n\n    if (typeof chunk === 'string' && // unless it is a string already ready for us to use\n    !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {\n      chunk = Buffer.from(chunk, encoding);\n    }\n\n    if (Buffer.isBuffer(chunk) && this[ENCODING]) chunk = this[DECODER].write(chunk); // Note: flushing CAN potentially switch us into not-flowing mode\n\n    if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);\n    if (this.flowing) this.emit('data', chunk);else this[BUFFERPUSH](chunk);\n    if (this[BUFFERLENGTH] !== 0) this.emit('readable');\n    if (cb) fn(cb);\n    return this.flowing;\n  }\n\n  read(n) {\n    if (this[DESTROYED]) return null;\n\n    if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {\n      this[MAYBE_EMIT_END]();\n      return null;\n    }\n\n    if (this[OBJECTMODE]) n = null;\n\n    if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {\n      if (this.encoding) this[BUFFER] = [this[BUFFER].join('')];else this[BUFFER] = [Buffer.concat(this[BUFFER], this[BUFFERLENGTH])];\n    }\n\n    const ret = this[READ](n || null, this[BUFFER][0]);\n    this[MAYBE_EMIT_END]();\n    return ret;\n  }\n\n  [READ](n, chunk) {\n    if (n === chunk.length || n === null) this[BUFFERSHIFT]();else {\n      this[BUFFER][0] = chunk.slice(n);\n      chunk = chunk.slice(0, n);\n      this[BUFFERLENGTH] -= n;\n    }\n    this.emit('data', chunk);\n    if (!this[BUFFER].length && !this[EOF]) this.emit('drain');\n    return chunk;\n  }\n\n  end(chunk, encoding, cb) {\n    if (typeof chunk === 'function') cb = chunk, chunk = null;\n    if (typeof encoding === 'function') cb = encoding, encoding = 'utf8';\n    if (chunk) this.write(chunk, encoding);\n    if (cb) this.once('end', cb);\n    this[EOF] = true;\n    this.writable = false; // if we haven't written anything, then go ahead and emit,\n    // even if we're not reading.\n    // we'll re-emit if a new 'end' listener is added anyway.\n    // This makes MP more suitable to write-only use cases.\n\n    if (this.flowing || !this[PAUSED]) this[MAYBE_EMIT_END]();\n    return this;\n  } // don't let the internal resume be overwritten\n\n\n  [RESUME]() {\n    if (this[DESTROYED]) return;\n    this[PAUSED] = false;\n    this[FLOWING] = true;\n    this.emit('resume');\n    if (this[BUFFER].length) this[FLUSH]();else if (this[EOF]) this[MAYBE_EMIT_END]();else this.emit('drain');\n  }\n\n  resume() {\n    return this[RESUME]();\n  }\n\n  pause() {\n    this[FLOWING] = false;\n    this[PAUSED] = true;\n  }\n\n  get destroyed() {\n    return this[DESTROYED];\n  }\n\n  get flowing() {\n    return this[FLOWING];\n  }\n\n  get paused() {\n    return this[PAUSED];\n  }\n\n  [BUFFERPUSH](chunk) {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;else this[BUFFERLENGTH] += chunk.length;\n    this[BUFFER].push(chunk);\n  }\n\n  [BUFFERSHIFT]() {\n    if (this[BUFFER].length) {\n      if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;else this[BUFFERLENGTH] -= this[BUFFER][0].length;\n    }\n\n    return this[BUFFER].shift();\n  }\n\n  [FLUSH](noDrain) {\n    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));\n\n    if (!noDrain && !this[BUFFER].length && !this[EOF]) this.emit('drain');\n  }\n\n  [FLUSHCHUNK](chunk) {\n    return chunk ? (this.emit('data', chunk), this.flowing) : false;\n  }\n\n  pipe(dest, opts) {\n    if (this[DESTROYED]) return;\n    const ended = this[EMITTED_END];\n    opts = opts || {};\n    if (dest === proc.stdout || dest === proc.stderr) opts.end = false;else opts.end = opts.end !== false;\n    opts.proxyErrors = !!opts.proxyErrors; // piping an ended stream ends immediately\n\n    if (ended) {\n      if (opts.end) dest.end();\n    } else {\n      this[PIPES].push(!opts.proxyErrors ? new Pipe(this, dest, opts) : new PipeProxyErrors(this, dest, opts));\n      if (this[ASYNC]) defer(() => this[RESUME]());else this[RESUME]();\n    }\n\n    return dest;\n  }\n\n  unpipe(dest) {\n    const p = this[PIPES].find(p => p.dest === dest);\n\n    if (p) {\n      this[PIPES].splice(this[PIPES].indexOf(p), 1);\n      p.unpipe();\n    }\n  }\n\n  addListener(ev, fn) {\n    return this.on(ev, fn);\n  }\n\n  on(ev, fn) {\n    const ret = super.on(ev, fn);\n    if (ev === 'data' && !this[PIPES].length && !this.flowing) this[RESUME]();else if (ev === 'readable' && this[BUFFERLENGTH] !== 0) super.emit('readable');else if (isEndish(ev) && this[EMITTED_END]) {\n      super.emit(ev);\n      this.removeAllListeners(ev);\n    } else if (ev === 'error' && this[EMITTED_ERROR]) {\n      if (this[ASYNC]) defer(() => fn.call(this, this[EMITTED_ERROR]));else fn.call(this, this[EMITTED_ERROR]);\n    }\n    return ret;\n  }\n\n  get emittedEnd() {\n    return this[EMITTED_END];\n  }\n\n  [MAYBE_EMIT_END]() {\n    if (!this[EMITTING_END] && !this[EMITTED_END] && !this[DESTROYED] && this[BUFFER].length === 0 && this[EOF]) {\n      this[EMITTING_END] = true;\n      this.emit('end');\n      this.emit('prefinish');\n      this.emit('finish');\n      if (this[CLOSED]) this.emit('close');\n      this[EMITTING_END] = false;\n    }\n  }\n\n  emit(ev, data) {\n    // error and close are only events allowed after calling destroy()\n    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED]) return;else if (ev === 'data') {\n      return !data ? false : this[ASYNC] ? defer(() => this[EMITDATA](data)) : this[EMITDATA](data);\n    } else if (ev === 'end') {\n      return this[EMITEND]();\n    } else if (ev === 'close') {\n      this[CLOSED] = true; // don't emit close before 'end' and 'finish'\n\n      if (!this[EMITTED_END] && !this[DESTROYED]) return;\n      const ret = super.emit('close');\n      this.removeAllListeners('close');\n      return ret;\n    } else if (ev === 'error') {\n      this[EMITTED_ERROR] = data;\n      const ret = super.emit('error', data);\n      this[MAYBE_EMIT_END]();\n      return ret;\n    } else if (ev === 'resume') {\n      const ret = super.emit('resume');\n      this[MAYBE_EMIT_END]();\n      return ret;\n    } else if (ev === 'finish' || ev === 'prefinish') {\n      const ret = super.emit(ev);\n      this.removeAllListeners(ev);\n      return ret;\n    } // Some other unknown event\n\n    for (var _len = arguments.length, extra = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      extra[_key - 2] = arguments[_key];\n    }\n\n    const ret = super.emit(ev, data, ...extra);\n    this[MAYBE_EMIT_END]();\n    return ret;\n  }\n\n  [EMITDATA](data) {\n    for (const p of this[PIPES]) {\n      if (p.dest.write(data) === false) this.pause();\n    }\n\n    const ret = super.emit('data', data);\n    this[MAYBE_EMIT_END]();\n    return ret;\n  }\n\n  [EMITEND]() {\n    if (this[EMITTED_END]) return;\n    this[EMITTED_END] = true;\n    this.readable = false;\n    if (this[ASYNC]) defer(() => this[EMITEND2]());else this[EMITEND2]();\n  }\n\n  [EMITEND2]() {\n    if (this[DECODER]) {\n      const data = this[DECODER].end();\n\n      if (data) {\n        for (const p of this[PIPES]) {\n          p.dest.write(data);\n        }\n\n        super.emit('data', data);\n      }\n    }\n\n    for (const p of this[PIPES]) {\n      p.end();\n    }\n\n    const ret = super.emit('end');\n    this.removeAllListeners('end');\n    return ret;\n  } // const all = await stream.collect()\n\n\n  collect() {\n    const buf = [];\n    if (!this[OBJECTMODE]) buf.dataLength = 0; // set the promise first, in case an error is raised\n    // by triggering the flow here.\n\n    const p = this.promise();\n    this.on('data', c => {\n      buf.push(c);\n      if (!this[OBJECTMODE]) buf.dataLength += c.length;\n    });\n    return p.then(() => buf);\n  } // const data = await stream.concat()\n\n\n  concat() {\n    return this[OBJECTMODE] ? Promise.reject(new Error('cannot concat in objectMode')) : this.collect().then(buf => this[OBJECTMODE] ? Promise.reject(new Error('cannot concat in objectMode')) : this[ENCODING] ? buf.join('') : Buffer.concat(buf, buf.dataLength));\n  } // stream.promise().then(() => done, er => emitted error)\n\n\n  promise() {\n    return new Promise((resolve, reject) => {\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')));\n      this.on('error', er => reject(er));\n      this.on('end', () => resolve());\n    });\n  } // for await (let chunk of stream)\n\n\n  [ASYNCITERATOR]() {\n    const next = () => {\n      const res = this.read();\n      if (res !== null) return Promise.resolve({\n        done: false,\n        value: res\n      });\n      if (this[EOF]) return Promise.resolve({\n        done: true\n      });\n      let resolve = null;\n      let reject = null;\n\n      const onerr = er => {\n        this.removeListener('data', ondata);\n        this.removeListener('end', onend);\n        reject(er);\n      };\n\n      const ondata = value => {\n        this.removeListener('error', onerr);\n        this.removeListener('end', onend);\n        this.pause();\n        resolve({\n          value: value,\n          done: !!this[EOF]\n        });\n      };\n\n      const onend = () => {\n        this.removeListener('error', onerr);\n        this.removeListener('data', ondata);\n        resolve({\n          done: true\n        });\n      };\n\n      const ondestroy = () => onerr(new Error('stream destroyed'));\n\n      return new Promise((res, rej) => {\n        reject = rej;\n        resolve = res;\n        this.once(DESTROYED, ondestroy);\n        this.once('error', onerr);\n        this.once('end', onend);\n        this.once('data', ondata);\n      });\n    };\n\n    return {\n      next\n    };\n  } // for (let chunk of stream)\n\n\n  [ITERATOR]() {\n    const next = () => {\n      const value = this.read();\n      const done = value === null;\n      return {\n        value,\n        done\n      };\n    };\n\n    return {\n      next\n    };\n  }\n\n  destroy(er) {\n    if (this[DESTROYED]) {\n      if (er) this.emit('error', er);else this.emit(DESTROYED);\n      return this;\n    }\n\n    this[DESTROYED] = true; // throw away all buffered data, it's never coming out\n\n    this[BUFFER].length = 0;\n    this[BUFFERLENGTH] = 0;\n    if (typeof this.close === 'function' && !this[CLOSED]) this.close();\n    if (er) this.emit('error', er);else // if no error to emit, still reject pending promises\n      this.emit(DESTROYED);\n    return this;\n  }\n\n  static isStream(s) {\n    return !!s && (s instanceof Minipass || s instanceof Stream || s instanceof EE && (typeof s.pipe === 'function' || // readable\n    typeof s.write === 'function' && typeof s.end === 'function' // writable\n    ));\n  }\n\n};","map":{"version":3,"names":["proc","process","stdout","stderr","EE","require","Stream","SD","StringDecoder","EOF","Symbol","MAYBE_EMIT_END","EMITTED_END","EMITTING_END","EMITTED_ERROR","CLOSED","READ","FLUSH","FLUSHCHUNK","ENCODING","DECODER","FLOWING","PAUSED","RESUME","BUFFER","PIPES","BUFFERLENGTH","BUFFERPUSH","BUFFERSHIFT","OBJECTMODE","DESTROYED","EMITDATA","EMITEND","EMITEND2","ASYNC","defer","fn","Promise","resolve","then","doIter","global","_MP_NO_ITERATOR_SYMBOLS_","ASYNCITERATOR","asyncIterator","ITERATOR","iterator","isEndish","ev","isArrayBuffer","b","ArrayBuffer","constructor","name","byteLength","isArrayBufferView","Buffer","isBuffer","isView","Pipe","src","dest","opts","ondrain","on","unpipe","removeListener","proxyErrors","end","PipeProxyErrors","er","emit","module","exports","Minipass","options","objectMode","encoding","async","writable","readable","debugExposeBuffer","Object","defineProperty","get","debugExposePipes","bufferLength","enc","Error","lastNeed","length","map","chunk","write","setEncoding","om","a","cb","assign","code","f","from","buffer","byteOffset","flowing","read","n","join","concat","ret","slice","once","resume","pause","destroyed","paused","push","shift","noDrain","pipe","ended","p","find","splice","indexOf","addListener","removeAllListeners","call","emittedEnd","data","extra","collect","buf","dataLength","promise","c","reject","next","res","done","value","onerr","ondata","onend","ondestroy","rej","destroy","close","isStream","s"],"sources":["C:/Users/Asus/Documents/threejs/miro learning/20.12 neuroweb textures/node_modules/minipass/index.js"],"sourcesContent":["'use strict'\nconst proc = typeof process === 'object' && process ? process : {\n  stdout: null,\n  stderr: null,\n}\nconst EE = require('events')\nconst Stream = require('stream')\nconst SD = require('string_decoder').StringDecoder\n\nconst EOF = Symbol('EOF')\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd')\nconst EMITTED_END = Symbol('emittedEnd')\nconst EMITTING_END = Symbol('emittingEnd')\nconst EMITTED_ERROR = Symbol('emittedError')\nconst CLOSED = Symbol('closed')\nconst READ = Symbol('read')\nconst FLUSH = Symbol('flush')\nconst FLUSHCHUNK = Symbol('flushChunk')\nconst ENCODING = Symbol('encoding')\nconst DECODER = Symbol('decoder')\nconst FLOWING = Symbol('flowing')\nconst PAUSED = Symbol('paused')\nconst RESUME = Symbol('resume')\nconst BUFFER = Symbol('buffer')\nconst PIPES = Symbol('pipes')\nconst BUFFERLENGTH = Symbol('bufferLength')\nconst BUFFERPUSH = Symbol('bufferPush')\nconst BUFFERSHIFT = Symbol('bufferShift')\nconst OBJECTMODE = Symbol('objectMode')\nconst DESTROYED = Symbol('destroyed')\nconst EMITDATA = Symbol('emitData')\nconst EMITEND = Symbol('emitEnd')\nconst EMITEND2 = Symbol('emitEnd2')\nconst ASYNC = Symbol('async')\n\nconst defer = fn => Promise.resolve().then(fn)\n\n// TODO remove when Node v8 support drops\nconst doIter = global._MP_NO_ITERATOR_SYMBOLS_  !== '1'\nconst ASYNCITERATOR = doIter && Symbol.asyncIterator\n  || Symbol('asyncIterator not implemented')\nconst ITERATOR = doIter && Symbol.iterator\n  || Symbol('iterator not implemented')\n\n// events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\nconst isEndish = ev =>\n  ev === 'end' ||\n  ev === 'finish' ||\n  ev === 'prefinish'\n\nconst isArrayBuffer = b => b instanceof ArrayBuffer ||\n  typeof b === 'object' &&\n  b.constructor &&\n  b.constructor.name === 'ArrayBuffer' &&\n  b.byteLength >= 0\n\nconst isArrayBufferView = b => !Buffer.isBuffer(b) && ArrayBuffer.isView(b)\n\nclass Pipe {\n  constructor (src, dest, opts) {\n    this.src = src\n    this.dest = dest\n    this.opts = opts\n    this.ondrain = () => src[RESUME]()\n    dest.on('drain', this.ondrain)\n  }\n  unpipe () {\n    this.dest.removeListener('drain', this.ondrain)\n  }\n  // istanbul ignore next - only here for the prototype\n  proxyErrors () {}\n  end () {\n    this.unpipe()\n    if (this.opts.end)\n      this.dest.end()\n  }\n}\n\nclass PipeProxyErrors extends Pipe {\n  unpipe () {\n    this.src.removeListener('error', this.proxyErrors)\n    super.unpipe()\n  }\n  constructor (src, dest, opts) {\n    super(src, dest, opts)\n    this.proxyErrors = er => dest.emit('error', er)\n    src.on('error', this.proxyErrors)\n  }\n}\n\nmodule.exports = class Minipass extends Stream {\n  constructor (options) {\n    super()\n    this[FLOWING] = false\n    // whether we're explicitly paused\n    this[PAUSED] = false\n    this[PIPES] = []\n    this[BUFFER] = []\n    this[OBJECTMODE] = options && options.objectMode || false\n    if (this[OBJECTMODE])\n      this[ENCODING] = null\n    else\n      this[ENCODING] = options && options.encoding || null\n    if (this[ENCODING] === 'buffer')\n      this[ENCODING] = null\n    this[ASYNC] = options && !!options.async || false\n    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null\n    this[EOF] = false\n    this[EMITTED_END] = false\n    this[EMITTING_END] = false\n    this[CLOSED] = false\n    this[EMITTED_ERROR] = null\n    this.writable = true\n    this.readable = true\n    this[BUFFERLENGTH] = 0\n    this[DESTROYED] = false\n    if (options && options.debugExposeBuffer === true) {\n      Object.defineProperty(this, 'buffer', { get: () => this[BUFFER] })\n    }\n    if (options && options.debugExposePipes === true) {\n      Object.defineProperty(this, 'pipes', { get: () => this[PIPES] })\n    }\n  }\n\n  get bufferLength () { return this[BUFFERLENGTH] }\n\n  get encoding () { return this[ENCODING] }\n  set encoding (enc) {\n    if (this[OBJECTMODE])\n      throw new Error('cannot set encoding in objectMode')\n\n    if (this[ENCODING] && enc !== this[ENCODING] &&\n        (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))\n      throw new Error('cannot change encoding')\n\n    if (this[ENCODING] !== enc) {\n      this[DECODER] = enc ? new SD(enc) : null\n      if (this[BUFFER].length)\n        this[BUFFER] = this[BUFFER].map(chunk => this[DECODER].write(chunk))\n    }\n\n    this[ENCODING] = enc\n  }\n\n  setEncoding (enc) {\n    this.encoding = enc\n  }\n\n  get objectMode () { return this[OBJECTMODE] }\n  set objectMode (om) { this[OBJECTMODE] = this[OBJECTMODE] || !!om }\n\n  get ['async'] () { return this[ASYNC] }\n  set ['async'] (a) { this[ASYNC] = this[ASYNC] || !!a }\n\n  write (chunk, encoding, cb) {\n    if (this[EOF])\n      throw new Error('write after end')\n\n    if (this[DESTROYED]) {\n      this.emit('error', Object.assign(\n        new Error('Cannot call write after a stream was destroyed'),\n        { code: 'ERR_STREAM_DESTROYED' }\n      ))\n      return true\n    }\n\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n\n    if (!encoding)\n      encoding = 'utf8'\n\n    const fn = this[ASYNC] ? defer : f => f()\n\n    // convert array buffers and typed array views into buffers\n    // at some point in the future, we may want to do the opposite!\n    // leave strings and buffers as-is\n    // anything else switches us into object mode\n    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n      if (isArrayBufferView(chunk))\n        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)\n      else if (isArrayBuffer(chunk))\n        chunk = Buffer.from(chunk)\n      else if (typeof chunk !== 'string')\n        // use the setter so we throw if we have encoding set\n        this.objectMode = true\n    }\n\n    // handle object mode up front, since it's simpler\n    // this yields better performance, fewer checks later.\n    if (this[OBJECTMODE]) {\n      /* istanbul ignore if - maybe impossible? */\n      if (this.flowing && this[BUFFERLENGTH] !== 0)\n        this[FLUSH](true)\n\n      if (this.flowing)\n        this.emit('data', chunk)\n      else\n        this[BUFFERPUSH](chunk)\n\n      if (this[BUFFERLENGTH] !== 0)\n        this.emit('readable')\n\n      if (cb)\n        fn(cb)\n\n      return this.flowing\n    }\n\n    // at this point the chunk is a buffer or string\n    // don't buffer it up or send it to the decoder\n    if (!chunk.length) {\n      if (this[BUFFERLENGTH] !== 0)\n        this.emit('readable')\n      if (cb)\n        fn(cb)\n      return this.flowing\n    }\n\n    // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n    if (typeof chunk === 'string' &&\n        // unless it is a string already ready for us to use\n        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {\n      chunk = Buffer.from(chunk, encoding)\n    }\n\n    if (Buffer.isBuffer(chunk) && this[ENCODING])\n      chunk = this[DECODER].write(chunk)\n\n    // Note: flushing CAN potentially switch us into not-flowing mode\n    if (this.flowing && this[BUFFERLENGTH] !== 0)\n      this[FLUSH](true)\n\n    if (this.flowing)\n      this.emit('data', chunk)\n    else\n      this[BUFFERPUSH](chunk)\n\n    if (this[BUFFERLENGTH] !== 0)\n      this.emit('readable')\n\n    if (cb)\n      fn(cb)\n\n    return this.flowing\n  }\n\n  read (n) {\n    if (this[DESTROYED])\n      return null\n\n    if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {\n      this[MAYBE_EMIT_END]()\n      return null\n    }\n\n    if (this[OBJECTMODE])\n      n = null\n\n    if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {\n      if (this.encoding)\n        this[BUFFER] = [this[BUFFER].join('')]\n      else\n        this[BUFFER] = [Buffer.concat(this[BUFFER], this[BUFFERLENGTH])]\n    }\n\n    const ret = this[READ](n || null, this[BUFFER][0])\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [READ] (n, chunk) {\n    if (n === chunk.length || n === null)\n      this[BUFFERSHIFT]()\n    else {\n      this[BUFFER][0] = chunk.slice(n)\n      chunk = chunk.slice(0, n)\n      this[BUFFERLENGTH] -= n\n    }\n\n    this.emit('data', chunk)\n\n    if (!this[BUFFER].length && !this[EOF])\n      this.emit('drain')\n\n    return chunk\n  }\n\n  end (chunk, encoding, cb) {\n    if (typeof chunk === 'function')\n      cb = chunk, chunk = null\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n    if (chunk)\n      this.write(chunk, encoding)\n    if (cb)\n      this.once('end', cb)\n    this[EOF] = true\n    this.writable = false\n\n    // if we haven't written anything, then go ahead and emit,\n    // even if we're not reading.\n    // we'll re-emit if a new 'end' listener is added anyway.\n    // This makes MP more suitable to write-only use cases.\n    if (this.flowing || !this[PAUSED])\n      this[MAYBE_EMIT_END]()\n    return this\n  }\n\n  // don't let the internal resume be overwritten\n  [RESUME] () {\n    if (this[DESTROYED])\n      return\n\n    this[PAUSED] = false\n    this[FLOWING] = true\n    this.emit('resume')\n    if (this[BUFFER].length)\n      this[FLUSH]()\n    else if (this[EOF])\n      this[MAYBE_EMIT_END]()\n    else\n      this.emit('drain')\n  }\n\n  resume () {\n    return this[RESUME]()\n  }\n\n  pause () {\n    this[FLOWING] = false\n    this[PAUSED] = true\n  }\n\n  get destroyed () {\n    return this[DESTROYED]\n  }\n\n  get flowing () {\n    return this[FLOWING]\n  }\n\n  get paused () {\n    return this[PAUSED]\n  }\n\n  [BUFFERPUSH] (chunk) {\n    if (this[OBJECTMODE])\n      this[BUFFERLENGTH] += 1\n    else\n      this[BUFFERLENGTH] += chunk.length\n    this[BUFFER].push(chunk)\n  }\n\n  [BUFFERSHIFT] () {\n    if (this[BUFFER].length) {\n      if (this[OBJECTMODE])\n        this[BUFFERLENGTH] -= 1\n      else\n        this[BUFFERLENGTH] -= this[BUFFER][0].length\n    }\n    return this[BUFFER].shift()\n  }\n\n  [FLUSH] (noDrain) {\n    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()))\n\n    if (!noDrain && !this[BUFFER].length && !this[EOF])\n      this.emit('drain')\n  }\n\n  [FLUSHCHUNK] (chunk) {\n    return chunk ? (this.emit('data', chunk), this.flowing) : false\n  }\n\n  pipe (dest, opts) {\n    if (this[DESTROYED])\n      return\n\n    const ended = this[EMITTED_END]\n    opts = opts || {}\n    if (dest === proc.stdout || dest === proc.stderr)\n      opts.end = false\n    else\n      opts.end = opts.end !== false\n    opts.proxyErrors = !!opts.proxyErrors\n\n    // piping an ended stream ends immediately\n    if (ended) {\n      if (opts.end)\n        dest.end()\n    } else {\n      this[PIPES].push(!opts.proxyErrors ? new Pipe(this, dest, opts)\n        : new PipeProxyErrors(this, dest, opts))\n      if (this[ASYNC])\n        defer(() => this[RESUME]())\n      else\n        this[RESUME]()\n    }\n\n    return dest\n  }\n\n  unpipe (dest) {\n    const p = this[PIPES].find(p => p.dest === dest)\n    if (p) {\n      this[PIPES].splice(this[PIPES].indexOf(p), 1)\n      p.unpipe()\n    }\n  }\n\n  addListener (ev, fn) {\n    return this.on(ev, fn)\n  }\n\n  on (ev, fn) {\n    const ret = super.on(ev, fn)\n    if (ev === 'data' && !this[PIPES].length && !this.flowing)\n      this[RESUME]()\n    else if (ev === 'readable' && this[BUFFERLENGTH] !== 0)\n      super.emit('readable')\n    else if (isEndish(ev) && this[EMITTED_END]) {\n      super.emit(ev)\n      this.removeAllListeners(ev)\n    } else if (ev === 'error' && this[EMITTED_ERROR]) {\n      if (this[ASYNC])\n        defer(() => fn.call(this, this[EMITTED_ERROR]))\n      else\n        fn.call(this, this[EMITTED_ERROR])\n    }\n    return ret\n  }\n\n  get emittedEnd () {\n    return this[EMITTED_END]\n  }\n\n  [MAYBE_EMIT_END] () {\n    if (!this[EMITTING_END] &&\n        !this[EMITTED_END] &&\n        !this[DESTROYED] &&\n        this[BUFFER].length === 0 &&\n        this[EOF]) {\n      this[EMITTING_END] = true\n      this.emit('end')\n      this.emit('prefinish')\n      this.emit('finish')\n      if (this[CLOSED])\n        this.emit('close')\n      this[EMITTING_END] = false\n    }\n  }\n\n  emit (ev, data, ...extra) {\n    // error and close are only events allowed after calling destroy()\n    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED])\n      return\n    else if (ev === 'data') {\n      return !data ? false\n        : this[ASYNC] ? defer(() => this[EMITDATA](data))\n        : this[EMITDATA](data)\n    } else if (ev === 'end') {\n      return this[EMITEND]()\n    } else if (ev === 'close') {\n      this[CLOSED] = true\n      // don't emit close before 'end' and 'finish'\n      if (!this[EMITTED_END] && !this[DESTROYED])\n        return\n      const ret = super.emit('close')\n      this.removeAllListeners('close')\n      return ret\n    } else if (ev === 'error') {\n      this[EMITTED_ERROR] = data\n      const ret = super.emit('error', data)\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'resume') {\n      const ret = super.emit('resume')\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'finish' || ev === 'prefinish') {\n      const ret = super.emit(ev)\n      this.removeAllListeners(ev)\n      return ret\n    }\n\n    // Some other unknown event\n    const ret = super.emit(ev, data, ...extra)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITDATA] (data) {\n    for (const p of this[PIPES]) {\n      if (p.dest.write(data) === false)\n        this.pause()\n    }\n    const ret = super.emit('data', data)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITEND] () {\n    if (this[EMITTED_END])\n      return\n\n    this[EMITTED_END] = true\n    this.readable = false\n    if (this[ASYNC])\n      defer(() => this[EMITEND2]())\n    else\n      this[EMITEND2]()\n  }\n\n  [EMITEND2] () {\n    if (this[DECODER]) {\n      const data = this[DECODER].end()\n      if (data) {\n        for (const p of this[PIPES]) {\n          p.dest.write(data)\n        }\n        super.emit('data', data)\n      }\n    }\n\n    for (const p of this[PIPES]) {\n      p.end()\n    }\n    const ret = super.emit('end')\n    this.removeAllListeners('end')\n    return ret\n  }\n\n  // const all = await stream.collect()\n  collect () {\n    const buf = []\n    if (!this[OBJECTMODE])\n      buf.dataLength = 0\n    // set the promise first, in case an error is raised\n    // by triggering the flow here.\n    const p = this.promise()\n    this.on('data', c => {\n      buf.push(c)\n      if (!this[OBJECTMODE])\n        buf.dataLength += c.length\n    })\n    return p.then(() => buf)\n  }\n\n  // const data = await stream.concat()\n  concat () {\n    return this[OBJECTMODE]\n      ? Promise.reject(new Error('cannot concat in objectMode'))\n      : this.collect().then(buf =>\n          this[OBJECTMODE]\n            ? Promise.reject(new Error('cannot concat in objectMode'))\n            : this[ENCODING] ? buf.join('') : Buffer.concat(buf, buf.dataLength))\n  }\n\n  // stream.promise().then(() => done, er => emitted error)\n  promise () {\n    return new Promise((resolve, reject) => {\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')))\n      this.on('error', er => reject(er))\n      this.on('end', () => resolve())\n    })\n  }\n\n  // for await (let chunk of stream)\n  [ASYNCITERATOR] () {\n    const next = () => {\n      const res = this.read()\n      if (res !== null)\n        return Promise.resolve({ done: false, value: res })\n\n      if (this[EOF])\n        return Promise.resolve({ done: true })\n\n      let resolve = null\n      let reject = null\n      const onerr = er => {\n        this.removeListener('data', ondata)\n        this.removeListener('end', onend)\n        reject(er)\n      }\n      const ondata = value => {\n        this.removeListener('error', onerr)\n        this.removeListener('end', onend)\n        this.pause()\n        resolve({ value: value, done: !!this[EOF] })\n      }\n      const onend = () => {\n        this.removeListener('error', onerr)\n        this.removeListener('data', ondata)\n        resolve({ done: true })\n      }\n      const ondestroy = () => onerr(new Error('stream destroyed'))\n      return new Promise((res, rej) => {\n        reject = rej\n        resolve = res\n        this.once(DESTROYED, ondestroy)\n        this.once('error', onerr)\n        this.once('end', onend)\n        this.once('data', ondata)\n      })\n    }\n\n    return { next }\n  }\n\n  // for (let chunk of stream)\n  [ITERATOR] () {\n    const next = () => {\n      const value = this.read()\n      const done = value === null\n      return { value, done }\n    }\n    return { next }\n  }\n\n  destroy (er) {\n    if (this[DESTROYED]) {\n      if (er)\n        this.emit('error', er)\n      else\n        this.emit(DESTROYED)\n      return this\n    }\n\n    this[DESTROYED] = true\n\n    // throw away all buffered data, it's never coming out\n    this[BUFFER].length = 0\n    this[BUFFERLENGTH] = 0\n\n    if (typeof this.close === 'function' && !this[CLOSED])\n      this.close()\n\n    if (er)\n      this.emit('error', er)\n    else // if no error to emit, still reject pending promises\n      this.emit(DESTROYED)\n\n    return this\n  }\n\n  static isStream (s) {\n    return !!s && (s instanceof Minipass || s instanceof Stream ||\n      s instanceof EE && (\n        typeof s.pipe === 'function' || // readable\n        (typeof s.write === 'function' && typeof s.end === 'function') // writable\n      ))\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}